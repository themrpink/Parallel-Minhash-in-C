{{disambiguation}}</text>
      <sha1>mcgjfvc5ewsxqycyxnhtdktp20vqgp5</sha1>
    </revision>
  </page>
  <page>
    <title>Control flow</title>
    <ns>0</ns>
    <id>45459</id>
    <revision>
      <id>988240787</id>
      <parentid>988240192</parentid>
      <timestamp>2020-11-11T23:21:24Z</timestamp>
      <contributor>
        <username>CLCStudent</username>
        <id>26398660</id>
      </contributor>
      <minor />
      <comment>Reverted 1 edit by [[Special:Contributions/72.176.144.37|72.176.144.37]] ([[User talk:72.176.144.37|talk]]) to last revision by Irontitan76</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="58866" xml:space="preserve">{{Distinguish|Flow control (data)}}
{{Loop constructs}}&lt;!-- NOTE: Please don't remove. Discuss navigation concept at [[Talk:Do_while_loop#Helpbox_experiment] --&gt;
In [[computer science]], '''control flow''' (or '''flow of control''') is the order in which individual [[Statement (computer science)|statements]], [[Instruction (computer science)|instructions]] or [[function call]]s of an [[imperative programming|imperative]] [[computer program|program]] are [[Execution (computing)|executed]] or evaluated. The emphasis on explicit control flow distinguishes an ''[[imperative programming]]'' language from a ''[[declarative programming]]'' language.

Within an imperative [[programming language]], a ''control flow statement'' is a statement that results in a choice being made as to which of two or more paths to follow. For [[Strict programming language|non-strict]] functional languages, functions and [[language construct]]s exist to achieve the same result, but they are usually not termed control flow statements.

A set of statements is in turn generally structured as a [[Block (programming)|block]], which in addition to grouping, also defines a [[lexical scope]].

[[Interrupt]]s and [[Signal (computing)|signals]] are low-level mechanisms that can alter the flow of control in a way similar to a subroutine, but usually occur as a response to some external stimulus or event (that can occur [[Asynchronous systems|asynchronously]]), rather than execution of an ''in-line'' control flow statement.

At the level of [[machine language]] or [[assembly language]], control flow instructions usually work by altering the [[program counter]]. For some [[central processing unit]]s (CPUs), the only control flow instructions available are conditional or unconditional [[Branch (computer science)|branch]] instructions, also termed jumps.

== Categories ==
[[File:For-loop-diagram.png|thumb|right|A [[flow chart]] showing control flow.]]
The kinds of control flow statements supported by different languages vary, but can be categorized by their effect:
* Continuation at a different statement (unconditional [[Branch (computer science)|branch]] or jump)
* Executing a set of statements only if some condition is met (choice - i.e., [[conditional branch]])
* Executing a set of statements zero or more times, until some condition is met (i.e., loop - the same as [[conditional branch]])
* Executing a set of distant statements, after which the flow of control usually returns ([[subroutine]]s, [[coroutine]]s, and [[continuation]]s)
* Stopping the program, preventing any further execution (unconditional halt)

== Primitives ==

=== Labels ===

{{main article|Label (computer science)}}
A [[Label (programming language)|label]] is an explicit name or number assigned to a fixed position within the [[source code]], and which may be referenced by control flow statements appearing elsewhere in the source code.  A label marks a position within source code and has no other effect.

[[Line number]]s are an alternative to a named label used in some languages (such as [[BASIC]]).  They are [[Natural number|whole numbers]] placed at the start of each line of text in the source code.  Languages which use these often impose the constraint that the line numbers must increase in value in each following line, but may not require that they be consecutive.  For example, in BASIC:

&lt;syntaxhighlight lang=&quot;qbasic&quot;&gt;
10 LET X = 3
20 PRINT X
&lt;/syntaxhighlight&gt;

In other languages such as [[C (programming language)|C]] and [[Ada (programming language)|Ada]], a label is an [[identifier]], usually appearing at the start of a line and immediately followed by a colon.  For example, in C:

&lt;syntaxhighlight lang=&quot;c&quot;&gt;
Success: printf(&quot;The operation was successful.\n&quot;);
&lt;/syntaxhighlight&gt;

The language [[ALGOL 60]] allowed both whole numbers and identifiers as labels (both linked by colons to the following statement), but few if any other [[ALGOL]] variants allowed whole numbers.  Early [[Fortran]] compilers only allowed whole numbers as labels.  Beginning with Fortran-90, alphanumeric labels have also been allowed.

=== Goto ===

{{main article|GOTO}}

The ''goto'' statement (a combination of the English words ''[[wiktionary:go|go]]'' and ''[[wiktionary:to|to]]'', and pronounced accordingly) is the most basic form of unconditional transfer of control.

Although the [[Keyword (computing)|keyword]] may either be in upper or lower case depending on the language, it is usually written as:
    '''goto''' ''label''
The effect of a goto statement is to cause the next statement to be executed to be the statement appearing at (or immediately after) the indicated label.

Goto statements have been [[considered harmful]] by many computer scientists, notably [[Edsger W. Dijkstra|Dijkstra]].

=== Subroutines ===

{{main article|Subroutine}}

The terminology for [[subroutine]]s varies; they may alternatively be known as routines, procedures, functions (especially if they return results) or methods (especially if they belong to [[Class (programming)|classes]] or [[type class]]es).

In the 1950s, computer memories were very small by current standards so subroutines were used mainly{{citation needed|date=May 2007}} to reduce program size.  A piece of code was written once and then used many times from various other places in a program.

Today, subroutines are more often used to help make a program more structured, e.g., by isolating some algorithm or hiding some data access method. If many programmers are working on one program, subroutines are one kind of [[Modularity (programming)|modularity]] that can help divide the work.

=== Sequence ===
{{main article|Structured programming}}

In structured programming, the ordered sequencing of successive commands is considered one of the basic control structures, which is used as a building block for programs alongside iteration, recursion and choice.

== Minimal structured control flow ==

{{See also|Structured program theorem}}
In May 1966, Böhm and Jacopini published an article&lt;ref&gt;Böhm, Jacopini. &quot;Flow diagrams, turing machines and languages with only two formation rules&quot; [[Comm. ACM]], 9(5):366-371, May 1966.&lt;/ref&gt; in ''Communications of the ACM'' which showed that any program with '''goto'''s could be transformed into a goto-free form involving only choice (IF THEN ELSE) and loops (WHILE condition DO xxx), possibly with duplicated code and/or the addition of Boolean variables (true/false flags). Later authors showed that choice can be replaced by loops (and yet more Boolean variables).

That such minimalism is possible does not mean that it is necessarily desirable; after all, computers theoretically need only [[One instruction set computer|one machine instruction]] (subtract one number from another and branch if the result is negative), but practical computers have dozens or even hundreds of machine instructions.

What Böhm and Jacopini's article showed was that all programs could be goto-free. Other research showed that control structures with one entry and one exit were much easier to understand than any other form,{{citation needed|date=July 2014}} mainly because they could be used anywhere as a statement without disrupting the control flow. In other words, they were ''composable''. (Later developments, such as [[non-strict programming language]]s – and more recently, composable [[software transactional memory|software transactions]] – have continued this strategy, making components of programs even more freely composable.)

Some academics took a purist approach to the Böhm-Jacopini result and argued that even instructions like &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; from the middle of loops are bad practice as they are not needed in the Böhm-Jacopini proof, and thus they advocated that all loops should have a single exit point. This purist approach is embodied in the language [[Pascal (programming language)|Pascal]] (designed in 1968–1969), which up to the mid-1990s was the preferred tool for teaching introductory programming in academia.&lt;ref name=&quot;roberts&quot;&gt;Roberts, E. [1995] “[http://cs.stanford.edu/people/eroberts/papers/SIGCSE-1995/LoopExits.pdf Loop Exits and Structured Programming: Reopening the Debate],” ACM SIGCSE Bulletin, (27)1: 268–272.&lt;/ref&gt; The direct application of the Böhm-Jacopini theorem may result in additional local variables being introduced in the structured chart, and may also result in some [[code duplication]].&lt;ref name=&quot;WattFindlay2004&quot;&gt;{{cite book|author1=David Anthony Watt|author2=William Findlay|title=Programming language design concepts|year=2004|publisher=John Wiley &amp; Sons|isbn=978-0-470-85320-7|pages=228}}&lt;/ref&gt; Pascal is affected by both of these problems and according to empirical studies cited by [[Eric S. Roberts]], student programmers had difficulty formulating correct solutions in Pascal for several simple problems, including writing a function for searching an element in an array. A 1980 study by Henry Shapiro cited by Roberts found that using only the Pascal-provided control structures, the correct solution was given by only 20% of the subjects, while no subject wrote incorrect code for this problem if allowed to write a return from the middle of a loop.&lt;ref name=&quot;roberts&quot;/&gt;

== Control structures in practice ==

Most programming languages with control structures have an initial keyword which indicates the type of control structure involved.{{clarify|date=November 2015}} Languages then divide as to whether or not control structures have a final keyword.

* No final keyword: [[ALGOL 60]], [[C (programming language)|C]], [[C++]], [[Haskell (programming language)|Haskell]], [[Java (programming language)|Java]], [[Pascal (programming language)|Pascal]], [[Perl]], [[PHP]], [[PL/I]], [[Python (programming language)|Python]], [[PowerShell]]. Such languages need some way of grouping statements together:
** ALGOL 60 and Pascal: &lt;code&gt;begin&lt;/code&gt; ... &lt;code&gt;end&lt;/code&gt;
** C, C++, Java, Perl, PHP, and PowerShell: [[Curly bracket programming language|curly brackets]] &lt;code&gt;{&lt;/code&gt; ... &lt;code&gt;}&lt;/code&gt;
** PL/I: &lt;code&gt;DO&lt;/code&gt; ... &lt;code&gt;END&lt;/code&gt;
** Python: uses [[Indent style|indent]] level (see [[Off-side rule]])
** Haskell: either [[Indent style|indent]] level or curly brackets can be used, and they can be freely mixed
** Lua: uses &lt;code&gt;do&lt;/code&gt; ... &lt;code&gt;end&lt;/code&gt;
* Final keyword: [[Ada (programming language)|Ada]], [[ALGOL 68]], [[Modula-2]], [[Fortran 77]], [[Mythryl]], [[Visual Basic]]. The forms of the final keyword vary:
** Ada: final keyword is &lt;code&gt;end&lt;/code&gt; + ''space'' + initial keyword e.g., &lt;code&gt;if&lt;/code&gt; ... &lt;code&gt;end if&lt;/code&gt;, &lt;code&gt;loop&lt;/code&gt; ... &lt;code&gt;end loop&lt;/code&gt;
** ALGOL 68, Mythryl: initial keyword spelled backwards e.g., &lt;code&gt;if&lt;/code&gt; ... &lt;code&gt;fi&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt; ... &lt;code&gt;esac&lt;/code&gt;
** Fortran 77: final keyword is &lt;code&gt;END&lt;/code&gt; + initial keyword e.g., &lt;code&gt;IF&lt;/code&gt; ... &lt;code&gt;ENDIF&lt;/code&gt;, &lt;code&gt;DO&lt;/code&gt; ... &lt;code&gt;ENDDO&lt;/code&gt;
** Modula-2: same final keyword &lt;code&gt;END&lt;/code&gt; for everything
** Visual Basic: every control structure has its own keyword. &lt;code&gt;If&lt;/code&gt; ... &lt;code&gt;End If&lt;/code&gt;; &lt;code&gt;For&lt;/code&gt; ... &lt;code&gt;Next&lt;/code&gt;; &lt;code&gt;Do&lt;/code&gt; ... &lt;code&gt;Loop&lt;/code&gt;; &lt;code&gt;While&lt;/code&gt; ... &lt;code&gt;Wend&lt;/code&gt;

== Choice ==

=== If-then-(else) statements ===

{{main article|Conditional (computer programming)}}
Conditional expressions and conditional constructs are features of a [[programming language]] which perform different computations or actions depending on whether a programmer-specified [[boolean datatype|boolean]] ''condition'' evaluates to true or false. 
* &lt;code&gt;IF..GOTO&lt;/code&gt;. A form found in unstructured languages, mimicking a typical machine code instruction, would jump to (GOTO) a label or line number when the condition was met.
* &lt;code&gt;IF..THEN..(ENDIF)&lt;/code&gt;. Rather than being restricted to a jump, any simple statement, or nested block, could follow the THEN key keyword. This a structured form.
* &lt;code&gt;IF..THEN..ELSE..(ENDIF)&lt;/code&gt;. As above, but with a second action to be performed if the condition is false. This is one of the most common forms, with many variations. Some require a terminal &lt;code&gt;ENDIF&lt;/code&gt;, others do not. [[C (programming language)|C]] and related languages do not require a terminal keyword, or a 'then', but do require parentheses around the condition.
* Conditional statements can be and often are nested inside other conditional statements. Some languages allow &lt;code&gt;ELSE&lt;/code&gt; and &lt;code&gt;IF&lt;/code&gt; to be combined into &lt;code&gt;ELSEIF&lt;/code&gt;, avoiding the need to have a series of &lt;code&gt;ENDIF&lt;/code&gt; or other final statements at the end of a compound statement.

{| class=&quot;wikitable&quot;
|-
! [[Pascal (programming language)|Pascal]]:
! [[Ada (programming language)|Ada]]:
! [[C (programming language)|C]]:
! [[Shell script]]:
! [[Python (programming language)|Python]]:
! [[Lisp (programming language)|Lisp]]:
|-valign=&quot;top&quot;
|&lt;syntaxhighlight lang=&quot;pascal&quot;&gt;
if a &gt; 0 then
  writeln(&quot;yes&quot;)
else
  writeln(&quot;no&quot;);
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;ada&quot;&gt;
if a &gt; 0 then
      Put_Line(&quot;yes&quot;);
else
      Put_Line(&quot;no&quot;);
end if;
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;c&quot;&gt;
if (a &gt; 0) { 
    printf(&quot;yes&quot;);
}
else {
    printf(&quot;no&quot;);
}
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
if [ $a -gt 0 ]; then
      echo &quot;yes&quot;
else
      echo &quot;no&quot;
fi
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;python&quot;&gt;
if a &gt; 0: 
    print(&quot;yes&quot;)
else:
    print(&quot;no&quot;)
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;lisp&quot;&gt;
(princ
  (if (plusp a)
      &quot;yes&quot;
      &quot;no&quot;))
&lt;/syntaxhighlight&gt;
|}
Less common variations include:
* Some languages, such as [[Fortran]], have a ''three-way'' or ''[[arithmetic if]]'', testing whether a numeric value is positive, negative or zero.
*Some languages have a [[Functional programming|functional]] form of an &lt;code&gt;if&lt;/code&gt; statement, for instance [[Lisp (programminglanguage)|Lisp's]] &lt;code&gt;cond&lt;/code&gt;.
*Some languages have an [[Operator (programming)|operator]] form of an &lt;code&gt;if&lt;/code&gt; statement, such as C's [[ternary operator]].
* [[Perl]] supplements a C-style &lt;code&gt;if&lt;/code&gt; with &lt;code&gt;when&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;.
* [[Smalltalk]] uses &lt;code&gt;ifTrue&lt;/code&gt; and &lt;code&gt;ifFalse&lt;/code&gt; messages to implement conditionals, rather than any fundamental language construct.

=== Case and switch statements ===

{{Main article|Switch statement}}

[[Switch statement]]s (or ''case statements'', or ''multiway branches'') compare a given value with specified constants and take action according to the first constant to match. There is usually a provision for a default action (&quot;else&quot;, &quot;otherwise&quot;) to be taken if no match succeeds. Switch statements can allow compiler optimizations, such as [[lookup table]]s. In [[dynamic language]]s, the cases may not be limited to constant expressions, and might extend to [[pattern matching]], as in the [[shell script]] example on the right, where the &lt;code&gt;*)&lt;/code&gt; implements the default case as a [[glob (programming)|glob]] matching any string. Case logic
can also be implemented in functional form, as in [[SQL]]'s &lt;code&gt;decode&lt;/code&gt; statement.&lt;!--Perl's implementation of case as a lookup table--&gt;

{| class=&quot;wikitable&quot;
|-
! [[Pascal (programming language)|Pascal]]:
! [[Ada (programming language)|Ada]]:
! [[C (programming language)|C]]:
! [[Shell script]]:
! [[Lisp (programming language)|Lisp]]:
|-
|&lt;syntaxhighlight lang=&quot;pascal&quot;&gt;
case someChar of
  'a': actionOnA;
  'x': actionOnX;
  'y','z':actionOnYandZ;
  else actionOnNoMatch;
end;
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;ada&quot;&gt;
case someChar is
  when 'a' =&gt; actionOnA;
  when 'x' =&gt; actionOnX;
  when 'y' | 'z' =&gt; actionOnYandZ;
  when others =&gt; actionOnNoMatch;
end;
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;c&quot;&gt;
switch (someChar) {
  case 'a': actionOnA; break;
  case 'x': actionOnX; break;
  case 'y':
  case 'z': actionOnYandZ; break;
  default: actionOnNoMatch;
}
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
case $someChar in 
   a)    actionOnA ;;
   x)    actionOnX ;;
   [yz]) actionOnYandZ ;;
   *)    actionOnNoMatch  ;;
esac
&lt;/syntaxhighlight&gt;
|&lt;syntaxhighlight lang=&quot;lisp&quot;&gt;
(case some-char
  ((#\a)     action-on-a)
  ((#\x)     action-on-x)
  ((#\y #\z) action-on-y-and-z)
  (else      action-on-no-match))
&lt;/syntaxhighlight&gt;
|}

== Loops ==

A loop is a sequence of statements which is specified once but which may be carried out several times in succession.
The code &quot;inside&quot; the loop (the ''body'' of the loop, shown below as ''xxx'') is obeyed a specified number of times, or once for each of a collection of items, or until some condition is met, or [[infinite loop|indefinitely]].

In [[functional programming]] languages, such as [[Haskell (programming language)|Haskell]] and [[Scheme (programming language)|Scheme]], loops can be expressed by using [[Recursion (computer science)|recursion]] or [[Fixed point combinator|fixed point iteration]] rather than explicit looping constructs. [[Tail recursion]] is a special case of recursion which can be easily transformed to iteration.

=== Count-controlled loops ===
{{main article|For loop}}
Most programming languages have constructions for repeating a loop a certain number of times.
In most cases counting can go downwards instead of upwards and step sizes other than 1 can be used.

    FOR I = 1 TO N           | '''for''' I := 1 '''to''' N '''do''' '''begin'''
        xxx                  |     xxx
    NEXT I                   | '''end''';
 ------------------------------------------------------------
    DO I = 1,N               | '''for''' ( I=1; I&lt;=N; ++I ) {
        xxx                  |     xxx
    END DO                   | }

In these examples, if N &lt; 1 then the body of loop may execute once (with I having value 1) or not at all, depending on the programming language.

In many programming languages, only integers can be reliably used in a count-controlled loop. Floating-point numbers are represented imprecisely due to hardware constraints, so a loop such as&lt;br&gt;
    '''for''' X := 0.1 '''step''' 0.1 '''to''' 1.0 '''do'''

might be repeated 9 or 10 times, depending on rounding errors and/or the hardware and/or the compiler version. Furthermore, if the increment of X occurs by repeated addition, accumulated rounding errors may mean that the value of X in each iteration can differ quite significantly from the expected sequence 0.1, 0.2, 0.3, ..., 1.0.
