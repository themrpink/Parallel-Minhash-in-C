== Special types of Gray codes ==

In practice, &quot;Gray code&quot; almost always refers to a binary-reflected Gray code (BRGC).
However, mathematicians have discovered other kinds of Gray codes.
Like BRGCs, each consists of a list of words, where each word differs from the next in only one digit (each word has a [[Hamming distance]] of 1 from the next word).

===''n''-ary Gray code===

{| border=&quot;0&quot; cellpadding=&quot;10&quot; align=&quot;right&quot;
|-
| &lt;!-- Second table to provide spacing around the inner table, can't get it otherwise… --&gt;
{| width=&quot;150&quot; align=&quot;right&quot; cellpadding=&quot;5&quot; border=&quot;1&quot; style=&quot;border-collapse: collapse;&quot;
|-
| ''Ternary number → ternary Gray code''
   0 → 000
   1 → 001
   2 → 002
  10 → 012
  11 → 011
  12 → 010
  20 → 020
  21 → 021
  22 → 022
 100 → 122
 101 → 121
 102 → 120
 110 → 110
 111 → 111
 112 → 112
 120 → 102
 121 → 101
 122 → 100
 200 → 200
 201 → 201
 202 → 202
 210 → 212
 211 → 211
 212 → 210
 220 → 220
 221 → 221
 222 → 222
|}
|}

There are many specialized types of Gray codes other than the binary-reflected Gray code. One such type of Gray code is the '''''n''-ary Gray code''', also known as a '''non-Boolean Gray code'''. As the name implies, this type of Gray code uses non-[[Boolean data type|Boolean]] values in its encodings.

For example, a 3-ary ([[ternary numeral system|ternary]]) Gray code would use the values {0, 1, 2}. The (''n'',&amp;nbsp;''k'')-''Gray code'' is the ''n''-ary Gray code with ''k'' digits.&lt;ref name=&quot;Guan_1998&quot;/&gt;
The sequence of elements in the (3,&amp;nbsp;2)-Gray code is: {00, 01, 02, 12, 11, 10, 20, 21, 22}. The (''n'',&amp;nbsp;''k'')-Gray code may be constructed recursively, as the BRGC, or may be constructed [[iteration|iteratively]]. An [[algorithm]] to iteratively generate the (''N'',&amp;nbsp;''k'')-Gray code is presented (in [[C (programming language)|C]]):

&lt;syntaxhighlight lang=&quot;C&quot;&gt;
// inputs: base, digits, value
// output: Gray
// Convert a value to a Gray code with the given base and digits.
// Iterating through a sequence of values would result in a sequence
// of Gray codes in which only one digit changes at a time.
void toGray(unsigned base, unsigned digits, unsigned value, unsigned gray[digits])
{ 
	unsigned baseN[digits];	// Stores the ordinary base-N number, one digit per entry
	unsigned i;		// The loop variable
 
	// Put the normal baseN number into the baseN array. For base 10, 109 
	// would be stored as [9,0,1]
	for (i = 0; i &lt; digits; i++) {
		baseN[i] = value % base;
		value    = value / base;
	}
 
	// Convert the normal baseN number into the Gray code equivalent. Note that
	// the loop starts at the most significant digit and goes down.
	unsigned shift = 0;
	while (i--) {
		// The Gray digit gets shifted down by the sum of the higher
		// digits.
		gray[i] = (baseN[i] + shift) % base;
		shift = shift + base - gray[i];	// Subtract from base so shift is positive
	}
}
// EXAMPLES
// input: value = 1899, base = 10, digits = 4
// output: baseN[] = [9,9,8,1], gray[] = [0,1,7,1]
// input: value = 1900, base = 10, digits = 4
// output: baseN[] = [0,0,9,1], gray[] = [0,1,8,1]
&lt;/syntaxhighlight&gt;

There are other Gray code algorithms for (''n'',''k'')-Gray codes. The (''n'',''k'')-Gray code produced by the above algorithm is always cyclical; some algorithms, such as that by Guan,&lt;ref name=&quot;Guan_1998&quot;/&gt; lack this property when k is odd. On the other hand, while only one digit at a time changes with this method, it can change by wrapping (looping from ''n''&amp;nbsp;−&amp;nbsp;1 to 0). In Guan's algorithm, the count alternately rises and falls, so that the numeric difference between two Gray code digits is always one.

Gray codes are not uniquely defined, because a permutation of the columns of such a code is a Gray code too. The above procedure produces a code in which the lower the significance of a digit, the more often it changes, making it similar to normal counting methods.

See also [[Skew binary number system]], a variant ternary number system where at most 2 digits change on each increment, as each increment can be done with at most one digit [[Carry (arithmetic)|carry]] operation.

===Balanced Gray code===

Although the binary reflected Gray code is useful in many scenarios, it is not optimal in certain cases because of a lack of &quot;uniformity&quot;.&lt;ref name=&quot;Bhat-Savage_1996&quot;/&gt; In '''balanced Gray codes''', the number of changes in different coordinate positions are as close as possible. To make this more precise, let ''G'' be an ''R''-ary complete Gray cycle having transition sequence &lt;math&gt;(\delta_k)&lt;/math&gt;; the ''transition counts'' (''spectrum'') of ''G'' are the collection of integers defined by

:&lt;math&gt;\lambda_k = |\{ j \in \mathbb{Z}_{R^n} : \delta_j = k \}| \, , \text { for } k \in \mathbb{Z}_n&lt;/math&gt;

A Gray code is ''uniform'' or ''uniformly balanced'' if its transition counts are all equal, in which case we have &lt;math&gt;\lambda_k = R^n / n&lt;/math&gt;
for all ''k''. Clearly, when &lt;math&gt;R = 2&lt;/math&gt;, such codes exist only if ''n'' is a power of 2. Otherwise, if ''n'' does not divide &lt;math&gt;R^n&lt;/math&gt; evenly, it is possible to construct ''well-balanced'' codes where every transition count is either &lt;math&gt;\lfloor R^n / n \rfloor&lt;/math&gt; or &lt;math&gt;\lceil R^n / n \rceil&lt;/math&gt;.&lt;ref name=&quot;Bhat-Savage_1996&quot;/&gt; Gray codes can also be ''exponentially balanced'' if all of their transition counts are adjacent powers of two, and such codes exist for every power of two.&lt;ref name=&quot;Suparta_2005&quot;/&gt;

For example, a balanced 4-bit Gray code has 16 transitions, which can be evenly distributed among all four positions (four transitions per position), making it uniformly balanced:&lt;ref name=&quot;Bhat-Savage_1996&quot;/&gt;
 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 
 0 0 {{fontcolor|red|1}} 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 1 {{fontcolor|red|0}} 0 0 0 
 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 
 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1

whereas a balanced 5-bit Gray code has a total of 32 transitions, which cannot be evenly distributed among the positions. In this example, four positions have six transitions each, and one has eight:&lt;ref name=&quot;Bhat-Savage_1996&quot;/&gt;
 {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 0 0 0 0 
 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 
 1 1 {{fontcolor|red|0}} 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 {{fontcolor|red|1}} 1 
 1 {{fontcolor|red|0}} 0 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 0 0 {{fontcolor|red|1}} 1 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 
 1 1 1 1 1 1 {{fontcolor|red|0}} 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 0 0 0 0 0 0 {{fontcolor|red|1}} 1 {{fontcolor|red|0}} 0 0 {{fontcolor|red|1}} 1 1 1 1 1

We will now show a construction&lt;ref name=&quot;Flahive-Bose_2007&quot;/&gt; and implementation&lt;ref name=&quot;Strackx-Piessens_2016&quot;/&gt; for well-balanced binary Gray codes which allows us to generate an ''n''-digit balanced Gray code for every ''n''. The main principle is to inductively construct an (''n''&amp;nbsp;+&amp;nbsp;2)-digit Gray code &lt;math&gt;G'&lt;/math&gt; given an ''n''-digit Gray code ''G'' in such a way that the balanced property is preserved. To do this, we consider partitions of &lt;math&gt;G = g_0, \ldots, g_{2^n-1}&lt;/math&gt; into an even number ''L'' of non-empty blocks of the form

: &lt;math&gt;\{g_0\}, \{g_1, \ldots, g_{k_2}\}, \{g_{k_2+1}, \ldots, g_{k_3}\}, \ldots, \{g_{k_{L-2}+1}, \ldots, g_{-2}\}, \{g_{-1}\}&lt;/math&gt;

where &lt;math&gt;k_1 = 0, k_{L-1} = -2&lt;/math&gt;, and &lt;math&gt;k_{L} = -1 \pmod{2^n}&lt;/math&gt;). This partition induces an &lt;math&gt;(n+2)&lt;/math&gt;-digit Gray code given by

:&lt;math&gt;00g_0,&lt;/math&gt;
:&lt;math&gt;00g_1, \ldots, 00g_{k_2}, 01g_{k_2}, \ldots, 01g_1, 11g_1, \ldots, 11g_{k_2}, &lt;/math&gt;
:&lt;math&gt;11g_{k_2+1}, \ldots, 11g_{k_3}, 01g_{k_3}, \ldots, 01g_{k_2+1}, 00g_{k_2+1}, \ldots, 00g_{k_3}, \ldots,&lt;/math&gt;
:&lt;math&gt;00g_{-2}, 00g_{-1}, 10g_{-1}, 10g_{-2}, \ldots, 10g_0, 11g_0, 11g_{-1}, 01g_{-1}, 01g_0&lt;/math&gt;

If we define the ''transition multiplicities'' &lt;math&gt;m_i = |\{ j : \delta_{k_j} = i, 1 \leq j \leq L \}|&lt;/math&gt; to be the number of times the digit in position ''i'' changes between consecutive blocks in a partition, then for the (''n''&amp;nbsp;+&amp;nbsp;2)-digit Gray code induced by this partition the transition spectrum &lt;math&gt;\lambda'_i&lt;/math&gt; is

: &lt;math&gt;
\lambda'_i = \begin{cases}
4 \lambda_i - 2 m_i, &amp; \text{if } 0 \leq i &lt; n \\
L, &amp; \text{ otherwise }
\end{cases}
&lt;/math&gt;

The delicate part of this construction is to find an adequate partitioning of a balanced ''n''-digit Gray code such that the code induced by it remains balanced, but for this only the transition multiplicities matter; joining two consecutive blocks over a digit &lt;math&gt;i&lt;/math&gt; transition and splitting another block at another digit &lt;math&gt;i&lt;/math&gt; transition produces a different Gray code with exactly the same transition spectrum &lt;math&gt;\lambda'_i&lt;/math&gt;, so one may for example&lt;ref name=&quot;Suparta_2005&quot;/&gt; designate the first &lt;math&gt;m_i&lt;/math&gt; transitions at digit &lt;math&gt;i&lt;/math&gt; as those that fall between two blocks. Uniform codes can be found when &lt;math&gt;R \equiv 0 \pmod 4&lt;/math&gt; and &lt;math&gt;R^n \equiv 0 \pmod n&lt;/math&gt;, and this construction can be extended to the ''R''-ary case as well.&lt;ref name=&quot;Flahive-Bose_2007&quot;/&gt;

=== Monotonic Gray codes ===

Monotonic codes are useful in the theory of interconnection networks, especially for minimizing dilation for linear arrays of processors.&lt;ref name=&quot;Savage-Winkler_1995&quot;/&gt;
If we define the ''weight'' of a binary string to be the number of 1s in the string, then although we clearly cannot have a Gray code with strictly increasing weight, we may want to approximate this by having the code run through two adjacent weights before reaching the next one.

We can formalize the concept of monotone Gray codes as follows: consider the partition of the hypercube &lt;math&gt;Q_n = (V_n, E_n)&lt;/math&gt; into ''levels'' of vertices that have equal weight, i.e.

: &lt;math&gt;V_n(i) = \{ v \in V_n : v \text{ has weight } i \}&lt;/math&gt;

for &lt;math&gt;0 \leq i \leq n&lt;/math&gt;. These levels satisfy &lt;math&gt;|V_n(i)| = \binom{n}{i}&lt;/math&gt;. Let &lt;math&gt;Q_n(i)&lt;/math&gt; be the subgraph of &lt;math&gt;Q_n&lt;/math&gt; induced by &lt;math&gt;V_n(i) \cup V_n(i+1)&lt;/math&gt;, and let &lt;math&gt;E_n(i)&lt;/math&gt; be the edges in &lt;math&gt;Q_n(i)&lt;/math&gt;. A monotonic Gray code is then a Hamiltonian path in &lt;math&gt;Q_n&lt;/math&gt; such that whenever &lt;math&gt;\delta_1 \in E_n(i)&lt;/math&gt; comes before &lt;math&gt;\delta_2 \in E_n(j)&lt;/math&gt; in the path, then &lt;math&gt;i \leq j&lt;/math&gt;.

An elegant construction of monotonic ''n''-digit Gray codes for any ''n'' is based on the idea of recursively building subpaths &lt;math&gt;P_{n,j}&lt;/math&gt; of length &lt;math&gt;2 \binom{n}{j}&lt;/math&gt; having edges in &lt;math&gt;E_n(j)&lt;/math&gt;.&lt;ref name=&quot;Savage-Winkler_1995&quot;/&gt; We define &lt;math&gt;P_{1,0} = (0, 1)&lt;/math&gt;, &lt;math&gt;P_{n,j} = \emptyset&lt;/math&gt; whenever &lt;math&gt;j &lt; 0&lt;/math&gt; or &lt;math&gt;j \geq n&lt;/math&gt;, and

: &lt;math&gt;
P_{n+1,j} = 1P^{\pi_n}_{n,j-1}, 0P_{n,j}
&lt;/math&gt;

otherwise. Here, &lt;math&gt;\pi_n&lt;/math&gt; is a suitably defined permutation and &lt;math&gt;P^{\pi}&lt;/math&gt; refers to the path ''P'' with its coordinates permuted by &lt;math&gt;\pi&lt;/math&gt;. These paths give rise to two monotonic ''n''-digit Gray codes &lt;math&gt;G_n^{(1)}&lt;/math&gt; and &lt;math&gt;G_n^{(2)}&lt;/math&gt; given by

: &lt;math&gt;
G_n^{(1)} = P_{n,0} P_{n,1}^R P_{n,2} P_{n,3}^R \cdots \text{ and } G_n^{(2)} = P_{n,0}^R P_{n,1} P_{n,2}^R P_{n,3} \cdots
&lt;/math&gt;

The choice of &lt;math&gt;\pi_n&lt;/math&gt; which ensures that these codes are indeed Gray codes turns out to be &lt;math&gt;\pi_n = E^{-1}(\pi_{n-1}^2)&lt;/math&gt;. The first few values of &lt;math&gt;P_{n,j}&lt;/math&gt; are shown in the table below.

{| class=&quot;wikitable infobox&quot; style=&quot;text-align: center;&quot;
|+ Subpaths in the Savage–Winkler algorithm
|-
! scope=&quot;col&quot; | &lt;math&gt;P_{n,j}&lt;/math&gt; 
! scope=&quot;col&quot; | ''j'' = 0
! scope=&quot;col&quot; | ''j'' = 1
! scope=&quot;col&quot; | ''j'' = 2
! scope=&quot;col&quot; | ''j'' = 3
|-
! scope=&quot;row&quot; | ''n'' = 1
| 0, 1 || || ||
|-
! scope=&quot;row&quot; | ''n'' = 2
| 00, 01 || 10, 11 || ||
|-
! scope=&quot;row&quot; | ''n'' = 3
| 000, 001 || 100, 110, 010, 011 || 101, 111 ||
|-
! scope=&quot;row&quot; | ''n'' = 4
| 0000,&lt;br&gt;0001 || 1000, 1100, 0100,&lt;br&gt;0110, 0010, 0011 || 1010, 1011, 1001,&lt;br&gt;1101, 0101, 0111 || 1110,&lt;br&gt;1111
|}

These monotonic Gray codes can be efficiently implemented in such a way that each subsequent element can be generated in ''O''(''n'') time. The algorithm is most easily described using [[coroutine]]s.

Monotonic codes have an interesting connection to the [[Lovász conjecture]], which states that every connected [[vertex-transitive graph]] contains a Hamiltonian path. The &quot;middle-level&quot; subgraph &lt;math&gt;Q_{2n+1}(n)&lt;/math&gt; is [[vertex-transitive graph|vertex-transitive]] (that is, its automorphism group is transitive, so that each vertex has the same &quot;local environment&quot;&quot; and cannot be differentiated from the others, since we can relabel the coordinates as well as the binary digits to obtain an [[automorphism]]) and the problem of finding a Hamiltonian path in this subgraph is called the &quot;middle-levels problem&quot;, which can provide insights into the more general conjecture. The question has been answered affirmatively for &lt;math&gt;n \leq 15&lt;/math&gt;, and the preceding construction for monotonic codes ensures a Hamiltonian path of length at least 0.839''N'' where ''N'' is the number of vertices in the middle-level subgraph.&lt;ref name=&quot;Savage_1997&quot;/&gt;

===Beckett–Gray code===

Another type of Gray code, the '''Beckett–Gray code''', is named for Irish playwright [[Samuel Beckett]], who was interested in [[symmetry]]. His play &quot;[[Quad (play)|Quad]]&quot; features four actors and is divided into sixteen time periods. Each period ends with one of the four actors entering or leaving the stage. The play begins with an empty stage, and Beckett wanted each subset of actors to appear on stage exactly once.&lt;ref name=&quot;Goddyn_1999&quot;/&gt; Clearly the set of actors currently on stage can be represented by a 4-bit binary Gray code. Beckett, however, placed an additional restriction on the script: he wished the actors to enter and exit so that the actor who had been on stage the longest would always be the one to exit. The actors could then be represented by a [[FIFO (computing and electronics)|first in, first out]] [[Queue (data structure)|queue]], so that (of the actors onstage) the actor being dequeued is always the one who was enqueued first.&lt;ref name=&quot;Goddyn_1999&quot;/&gt; Beckett was unable to find a Beckett–Gray code for his play, and indeed, an exhaustive listing of all possible sequences reveals that no such code exists for ''n'' = 4. It is known today that such codes do exist for ''n'' = 2, 5, 6, 7, and 8, and do not exist for ''n'' = 3 or 4. An example of an 8-bit Beckett–Gray code can be found in [[Donald Knuth]]'s ''Art of Computer Programming''.&lt;ref name=&quot;Knuth&quot;/&gt; According to Sawada and Wong, the search space for ''n'' = 6 can be explored in 15 hours, and more than 9,500 solutions for the case ''n'' = 7 have been found.&lt;ref name=&quot;Sawada-Wong_2007&quot;/&gt;

=== {{anchor|Kautz}}Snake-in-the-box codes ===

[[Snake-in-the-box]] codes, or ''snakes'', are the sequences of nodes of [[induced path]]s in an ''n''-dimensional [[hypercube graph]], and coil-in-the-box codes,&lt;ref name=&quot;Richards_1971&quot;/&gt; or ''coils'', are the sequences of nodes of induced [[cycle (graph theory)|cycles]] in a hypercube. Viewed as Gray codes, these sequences have the property of being able to detect any single-bit coding error. Codes of this type were first described by [[William H. Kautz]] in the late 1950s;&lt;ref name=&quot;Kautz_1958&quot;/&gt; since then, there has been much research on finding the code with the largest possible number of codewords for a given hypercube dimension.

==={{anchor|STGC}}Single-track Gray code===

Yet another kind of Gray code is the '''single-track Gray code''' (STGC) developed by Norman B. Spedding&lt;ref name=&quot;Spedding_1994_1&quot;/&gt;&lt;ref name=&quot;Spedding_1994_2&quot;/&gt; and refined by Hiltgen, Paterson and Brandestini in &quot;Single-track Gray codes&quot; (1996).&lt;ref name=&quot;Hiltgen-Paterson-Brandestini_1996&quot;/&gt;&lt;ref name=&quot;Hiltgen-Paterson_2001&quot;/&gt; The STGC is a cyclical list of ''P'' unique binary encodings of length n such that two consecutive words differ in exactly one position, and when the list is examined as a ''P''&amp;nbsp;×&amp;nbsp;''n'' [[Matrix (mathematics)|matrix]], each column is a cyclic shift of the first column.&lt;ref name=&quot;Etzion-Schwartz_1999&quot;/&gt;

[[File:Enkelspoors-Graycode.svg|thumb|Single-track Gray code with 5 sensors.]]
[[File:Animated Graycode.gif|thumb|Animated and color-coded version of the STGC rotor.]]

The name comes from their use with [[rotary encoder]]s, where a number of tracks are being sensed by contacts, resulting for each in an output of 0 or 1. To reduce noise due to different contacts not switching at exactly the same moment in time, one preferably sets up the tracks so that the data output by the contacts are in Gray code. To get high angular accuracy, one needs lots of contacts; in order to achieve at least 1 degree accuracy, one needs at least 360 distinct positions per revolution, which requires a minimum of 9 bits of data, and thus the same number of contacts.

If all contacts are placed at the same angular position, then 9 tracks are needed to get a standard BRGC with at least 1 degree accuracy. However, if the manufacturer moves a contact to a different angular position (but at the same distance from the center shaft), then the corresponding &quot;ring pattern&quot; needs to be rotated the same angle to give the same output. If the most significant bit (the inner ring in Figure 1) is rotated enough, it exactly matches the next ring out. Since both rings are then identical, the inner ring can be cut out, and the sensor for that ring moved to the remaining, identical ring (but offset at that angle from the other sensor on that ring). Those two sensors on a single ring make a quadrature encoder. That reduces the number of tracks for a &quot;1 degree resolution&quot; angular encoder to 8 tracks. Reducing the number of tracks still further can't be done with BRGC.

For many years, Torsten Sillke&lt;ref name=&quot;Sillke_1997&quot;/&gt; and other mathematicians believed that it was impossible to encode position on a single track such that consecutive positions differed at only a single sensor, except for the 2-sensor, 1-track quadrature encoder. So for applications where 8 tracks were too bulky, people used single-track incremental encoders (quadrature encoders) or 2-track &quot;quadrature encoder + reference notch&quot; encoders.

Norman B. Spedding, however, registered a patent in 1994 with several examples showing that it was possible.&lt;ref name=&quot;Spedding_1994_1&quot;/&gt; Although it is not possible to distinguish 2&lt;sup&gt;''n''&lt;/sup&gt; positions with ''n'' sensors on a single track, it ''is'' possible to distinguish close to that many.  Etzion and Paterson conjecture that when ''n'' is itself a power of 2, ''n'' sensors can distinguish at most 2&lt;sup&gt;''n''&lt;/sup&gt;&amp;nbsp;−&amp;nbsp;2''n'' positions and that for prime ''n'' the limit is 2&lt;sup&gt;''n''&lt;/sup&gt;&amp;nbsp;−&amp;nbsp;2 positions.&lt;ref name=&quot;Etzion-Paterson_1996&quot;/&gt; The authors went on to generate a 504 position single track code of length 9 which they believe is optimal. Since this number is larger than 2&lt;sup&gt;8&lt;/sup&gt; = 256, more than 8 sensors are required by any code, although a BRGC could distinguish 512 positions with 9 sensors.

An STGC for ''P''&amp;nbsp;=&amp;nbsp;30 and ''n''&amp;nbsp;=&amp;nbsp;5 is reproduced here:
{|class=&quot;wikitable&quot; style=&quot;text-align:center; background:#FFFFFF; border-width:0;&quot;
|+ Single-track Gray code for 30 positions
! Angle || Code
|rowspan=&quot;7&quot; style=&quot;text-align:center; background:#FFFFFF; border-width:0;&quot;|
! Angle || Code
|rowspan=&quot;7&quot; style=&quot;text-align:center; background:#FFFFFF; border-width:0;&quot;|
! Angle || Code
|rowspan=&quot;7&quot; style=&quot;text-align:center; background:#FFFFFF; border-width:0;&quot;|
! Angle || Code
|rowspan=&quot;7&quot; style=&quot;text-align:center; background:#FFFFFF; border-width:0;&quot;|
! Angle || Code
|-
|   0° || 10000 ||  72° || 01000 || 144° || 00100 || 216° || 00010 || 288° || 00001
|-
|  12° || 10100 ||  84° || 01010 || 156° || 00101 || 228° || 10010 || 300° || 01001
|-
|  24° || 11100 ||  96° || 01110 || 168° || 00111 || 240° || 10011 || 312° || 11001
|-
|  36° || 11110 || 108° || 01111 || 180° || 10111 || 252° || 11011 || 324° || 11101
|-
|  48° || 11010 || 120° || 01101 || 192° || 10110 || 264° || 01011 || 336° || 10101
|-
|  60° || 11000 || 132° || 01100 || 204° || 00110 || 276° || 00011 || 348° || 10001
|}
&lt;!--
But even better would be an actual illustration of the single track, on a rotary encoder, with the 5 pick-up sensors.
This is done – does that mean that the 1s and 0s can go now? They take up a whole lot of visual space.
--&gt;

Each column is a cyclic shift of the first column, and from any row to the next row only one bit changes.&lt;ref name=&quot;Ruskey_2005&quot;/&gt;
The single-track nature (like a code chain) is useful in the fabrication of these wheels (compared to BRGC), as only one track is needed, thus reducing their cost and size.
The Gray code nature is useful (compared to [[chain code]]s, also called [[De Bruijn sequence]]s), as only one sensor will change at any one time, so the uncertainty during a transition between two discrete states will only be plus or minus one unit of angular measurement the device is capable of resolving.&lt;ref name=&quot;Alciatore-Histand_1999&quot;/&gt;

===Two-dimensional Gray code===
