CP/M used the 7-bit ASCII set. The other 128 characters made possible by the 8-bit byte were not standardized. For example, one [[Kaypro]] used them for Greek characters, and [[Osborne Computer Corporation|Osborne]] machines used the 8th bit set to indicate an underlined character. [[WordStar]] used the 8th bit as an end-of-word marker. International CP/M systems most commonly used the [[ISO 646]] norm for localized character sets, replacing certain ASCII characters with localized characters rather than adding them beyond the 7-bit boundary.

==Components of the operating system==
In the 8-bit versions, while running, the CP/M operating system loaded into memory had three components:&lt;ref name=&quot;CPM.NYT83&quot;/&gt;
* ''[[#BIOS|Basic Input/Output System]]'' (BIOS),
* ''[[#BDOS|Basic Disk Operating System]]'' (BDOS),
* ''[[#CCP|Console Command Processor]]'' (CCP).
The BIOS and BDOS were memory-resident, while the CCP was memory-resident unless overwritten by an application, in which case it was automatically reloaded after the application finished running. A number of transient commands for standard utilities were also provided. The transient commands resided in [[Computer file|files]] with the [[filename extension|extension]] .COM on disk.

The BIOS directly controlled hardware components other than the CPU and main memory. It contained functions such as character input and output and the reading and writing of disk sectors. The BDOS implemented the CP/M [[file system]] and some input/output abstractions (such as redirection) on top of the BIOS. The CCP took user commands and either executed them directly (internal commands such as DIR to show a directory or ERA to delete a file) or loaded and started an executable file of the given name (transient commands such as PIP.COM to copy files or STAT.COM to show various file and system information). Third-party applications for CP/M were also essentially transient commands.

The BDOS, CCP and standard transient commands were (ideally) the same in all installations of a particular revision of CP/M, but the BIOS portion was always adapted to the particular hardware. Adding memory to a computer, for example, meant that the CP/M system had to be reinstalled with an updated BIOS capable of addressing the additional memory. A utility was provided to patch the supplied BIOS, BDOS and CCP to allow them to be run from higher memory. Once installed, the operating system (BIOS, BDOS and CCP) was stored in reserved areas at the beginning of any disk which would be used to boot the system. On start-up, the bootloader (usually contained in a ROM firmware chip) would load the operating system from the disk in drive &lt;code&gt;A:&lt;/code&gt;.

By modern standards CP/M was primitive, owing to the extreme constraints on program size. With version 1.0 there was no provision for detecting a changed disk. If a user changed disks without manually rereading the disk directory the system would write on the new disk using the old disk's directory information, ruining the data stored on the disk. From version 1.1 or 1.2 onwards, changing a disk then trying to write to it before its directory was read would cause a fatal error to be signalled. This avoided overwriting the disk but required a reboot and loss of the data that was to be stored on disk.

The majority of the complexity in CP/M was isolated in the BDOS, and to a lesser extent, the CCP and transient commands. This meant that by porting the limited number of simple routines in the BIOS to a particular hardware platform, the entire OS would work. This significantly reduced the development time needed to support new machines, and was one of the main reasons for CP/M's widespread use. Today this sort of abstraction is common to most OSs (a [[hardware abstraction layer]]), but at the time of CP/M's birth, OSs were typically intended to run on only one machine platform, and multilayer designs were considered unnecessary.

==={{anchor|CCP}}Console Command Processor===
&lt;!-- This section may be linked to from inside or outside this article. Do not rename without keeping in sync. --&gt;
[[File:Commodore C128 CPM Screenshot 2 full.jpg|300px|thumb|right|Screenshot showing a CP/M 3.0 directory listing using the &lt;code&gt;[[dir (command)|DIR]]&lt;/code&gt; command on a [[Commodore 128]] home computer.]]
The Console Command Processor, or CCP, accepted input from the keyboard and conveyed results to the terminal. CP/M itself would work with either a printing terminal or a video terminal. All CP/M commands had to be typed in on the [[command line]]. The console would most often display the &lt;code&gt;A&gt;&lt;/code&gt; prompt, to indicate the current default disk drive. When used with a video terminal, this would usually be followed by a blinking [[Cursor (computers)|cursor]] supplied by the terminal. The CCP would await input from the user.

A CCP internal command, of the form drive letter followed by a colon, could be used to select the default drive. For example, typing &lt;code&gt;B:&lt;/code&gt; and pressing enter at the command prompt would change the default drive to B, and the command prompt would then become &lt;code&gt;B&gt;&lt;/code&gt; to indicate this change.

CP/M's [[command-line interface]] was patterned after the operating systems from [[Digital Equipment Corporation|Digital Equipment]], such as [[RT-11]] for the [[PDP-11]] and [[OS/8]] for the [[PDP-8]].

Commands took the form of a keyword followed by a list of parameters separated by spaces or special characters. Similar to a Unix [[shell builtin]], if an internal command was recognized, it was carried out by the CCP itself. Otherwise it would attempt to find an executable file on the currently logged disk drive and (in later versions) user area, load it, and pass it any additional parameters from the command line. These were referred to as &quot;transient&quot; programs. On completion, CP/M would reload the part of the CCP that had been overwritten by application programs — this allowed transient programs a larger memory space.

The commands themselves could sometimes be obscure. For instance, the command to duplicate files was named &lt;code&gt;[[Peripheral Interchange Program|PIP]]&lt;/code&gt; (Peripheral-Interchange-Program), the name of the old [[Digital Equipment Corporation|DEC]] utility used for that purpose. The format of parameters given to a program was not standardized, so that there was no single option character that differentiated options from file names. Different programs could and did use different characters.

===={{anchor|MOVCPM}}Commands====
The following list of [[Shell builtin|built-in]] [[command (computing)|commands]] are supported by the CP/M Console Command Processor:&lt;ref name=&quot;CPM22&quot;/&gt;
{{div col|colwidth=9em}}
* [[DIR (CP/M command)|DIR]]
* [[ERA (CP/M command)|ERA]]
* [[REN (CP/M command)|REN]]
* [[SAVE (CP/M command)|SAVE]]
* [[TYPE (CP/M command)|TYPE]]
* [[USER (CP/M command)|USER]]
{{div col end}}

Transient commands in CP/M include:&lt;ref name=&quot;CPM22&quot;/&gt;
{{div col|colwidth=9em}}
* [[Assembler (computing)|ASM]]
* [[DDT (CP/M command)|DDT]]
* [[DUMP (CP/M command)|DUMP]]
* [[ED (CP/M command)|ED]]
* [[LOAD (CP/M command)|LOAD]]
* {{ill|MOVCPM|pl|MOVCPM (CP/M)}}
* [[PIP (CP/M command)|PIP]]
* [[STAT (CP/M command)|STAT]]
* [[SUBMIT (CP/M command)|SUBMIT]]
* [[SYSGEN (CP/M command)|SYSGEN]]
{{div col end}}

CP/M Plus (CP/M Version 3) includes the following built-in commands:&lt;ref name=&quot;CPM3_1983_PG&quot;/&gt;
* DIR – display list of files from a directory except those marked with the SYS attribute
* [[DIRSYS (CP/M command)|DIRSYS]] / [[DIRS (CP/M command)|DIRS]] – list files marked with the SYS attribute in the directory
* [[ERASE (CP/M command)|ERASE]] / ERA – delete a file
* [[RENAME (CP/M command)|RENAME]] / REN – rename a file
* TYPE / [[TYP (CP/M command)|TYP]] – display contents of an ASCII character file
* USER / [[USE (CP/M command)|USE]] – change user number

CP/M 3 allows the user to abbreviate the built-in commands.&lt;ref name=&quot;CPM3&quot;&gt;[http://www.bitsavers.org/pdf/digitalResearch/cpm_plus/CPM_Plus_Users_Guide_Mar83.pdf CP/M Plus (CP/M Version 3) Operating System User's Guide]&lt;/ref&gt;

Transient commands in CP/M 3 include:&lt;ref name=&quot;CPM3&quot;/&gt;
{{div col|colwidth=9em}}
* [[SYSGEN (CP/M command)|COPYSYS]]
* [[DATE (CP/M command)|DATE]]
* [[DEVICE (CP/M command)|DEVICE]]
* [[DUMP (CP/M command)|DUMP]]
* [[ED (CP/M command)|ED]]
* [[GET (CP/M command)|GET]]
* [[HELP (CP/M command)|HELP]]
* [[HEXCOM (CP/M command)|HEXCOM]]
* [[INITDIR (CP/M command)|INITDIR]]
* [[LINK (CP/M command)|LINK]]
* [[MAC (CP/M command)|MAC]]
* [[PIP (CP/M command)|PIP]]
* [[PUT (CP/M command)|PUT]]
* [[RMAC (CP/M command)|RMAC]]
* [[SET (CP/M command)|SET]]
* [[SETDEF (CP/M command)|SETDEF]]
* [[SHOW (CP/M command)|SHOW]]
* [[SID (CP/M command)|SID]]
* [[SUBMIT (CP/M command)|SUBMIT]]
* [[XREF (CP/M command)|XREF]]
{{div col end}}

==={{anchor|BDOS}}Basic Disk Operating System===
&lt;!-- This section may be linked to from inside or outside this article. Do not rename without keeping in sync. --&gt;
The Basic Disk Operating System,&lt;ref name=&quot;Kildall_1975_BDOS&quot;/&gt;&lt;ref name=&quot;Kildall_1980_CPM&quot;/&gt; or BDOS,&lt;ref name=&quot;Kildall_1975_BDOS&quot;/&gt;&lt;ref name=&quot;Kildall_1980_CPM&quot;/&gt; provided access to such operations as opening a file, output to the console, or printing. Application programs would load processor registers with a function code for the operation, and addresses for parameters or memory buffers, and call a fixed address in memory. Since the address was the same independent of the amount of memory in the system, application programs would run the same way for any type or configuration of hardware.

==={{anchor|BIOS}}Basic Input Output System===
[[File:CP⁄M Ad, Dec 11, 1978.png|thumbnail|right|CP/M advertisement in the 11 December 1978, issue of ''[[InfoWorld]]'' magazine]]
&lt;!-- This section may be linked to from inside or outside this article. Do not rename without keeping in sync. --&gt;
&lt;!-- These two sources are not currently used inhere, but may become useful in the future:&lt;ref name=&quot;Fischer_2001_Ewing&quot;/&gt;&lt;ref name=&quot;Fraley_2007_Killian&quot;/&gt; --&gt;
The Basic Input Output System,&lt;ref name=&quot;Kildall_1975_BDOS&quot;/&gt;&lt;ref name=&quot;Kildall_1980_CPM&quot;/&gt; or BIOS,&lt;ref name=&quot;Kildall_1975_BDOS&quot;/&gt;&lt;ref name=&quot;Kildall_1980_CPM&quot;/&gt; provided the lowest level functions required by the operating system.

These included reading or writing single characters to the system console and reading or writing a sector of data from the disk. The BDOS handled some of the buffering of data from the diskette, but before CP/M&amp;nbsp;3.0 it assumed a disk sector size fixed at 128 bytes, as used on [[single-density]] 8-inch floppy disks. Since most 5.25-inch disk formats used larger sectors, the blocking and deblocking and the management of a disk buffer area was handled by model-specific code in the BIOS.

Customization was required because hardware choices were not constrained by compatibility with any one popular standard. For example, some manufacturers used a separate computer terminal, while others designed a built-in integrated video display system. Serial ports for printers and modems could use different types of [[UART]] chips, and port addresses were not fixed. Some machines used memory-mapped I/O instead of the 8080 I/O address space. All of these variations in the hardware were concealed from other modules of the system by use of the BIOS, which used standard entry points for the services required to run CP/M such as character I/O or accessing a disk block. Since support for serial communication to a modem was very rudimentary in the BIOS or may have been absent altogether, it was common practice for CP/M programs that used modems to have a user-installed overlay containing all the code required to access a particular machine's serial port.

==={{anchor|FDOS|2.2}}File system===
File names were specified as a string of up to eight characters, followed by a period, followed by a file name extension of up to three characters ([[8.3 filename|&quot;8.3&quot; filename format]]). The extension usually identified the type of the file. For example, &lt;code&gt;.COM&lt;/code&gt; indicated an executable program file, and &lt;code&gt;.TXT&lt;/code&gt; indicated a file containing [[ASCII]] text.

Each disk drive was identified by a [[drive letter]], for example drive &lt;code&gt;A&lt;/code&gt; and drive &lt;code&gt;B&lt;/code&gt;. To refer to a file on a specific drive, the drive letter was prefixed to the file name, separated by a colon, e.g. &lt;code&gt;A:FILE.TXT&lt;/code&gt;. With no drive letter prefixed, access was to files on the current default drive.&lt;ref name=&quot;px4&quot;/&gt;

The &quot;8.3&quot; filename format and the drive letter + colon combination survived into MS-DOS. The drive letter + colon convention has survived in [[Microsoft Windows]] and is still used today. In addition, file extensions (for example, &lt;code&gt;[[.txt]]&lt;/code&gt;, &lt;code&gt;[[COM file|.com]]&lt;/code&gt; (a [[compiled]] file), or &lt;code&gt;[[.exe]]&lt;/code&gt; (an [[executable]] file)) are still used to identify file types on many operating systems.

File size was specified as the number of 128 byte ''records'' (directly corresponding to disk sectors on 8-inch drives) occupied by a file on the disk. There was no generally supported way of specifying byte-exact file sizes. The current size of a file was maintained in the file's [[File Control Block]] (FCB) by the operating system. Since many application programs (such as [[text editors]]) prefer to deal with files as sequences of characters rather than as sequences of records, by convention text files were terminated with a [[control-Z]] character ([[ASCII]] [[Substitute character|SUB]], [[hexadecimal]] 1A). Determining the [[End-of-file|end]] of a [[text file]] therefore involved examining the last record of the file to locate the terminating control-Z. This also meant that inserting a control-Z character into the middle of a file usually had the effect of truncating the text contents of the file.

With the advent of larger removable and fixed disk drives, disk de-blocking formulas were employed which resulted in more disk blocks per logical file allocation block. While this allowed for larger file sizes, it also meant that the smallest file which could be allocated increased in size from 1&amp;nbsp;[[Kilobyte|KB]] (on single-density drives) to 2&amp;nbsp;KB (on double-density drives) and so on, up to 32&amp;nbsp;KB for a file containing only a single byte. This made for inefficient use of disk space if the disk contained a large number of small files.

File modification [[system time|time stamps]] were not supported in releases up to CP/M&amp;nbsp;2.2, but were an optional feature in [[MP/M]] and CP/M&amp;nbsp;3.0.

CP/M&amp;nbsp;2.2 had no subdirectories in the file structure, but provided 16 numbered user areas to organize files on a disk. To change user one had to simply type &quot;User X&quot; at the command prompt, X being the number of the user wanted; security was non-existent and not believed to be necessary. The user area concept was to make the single-user version of CP/M somewhat compatible with multi-user MP/M systems. A common patch for the CP/M and derivative operating systems was to make one user area accessible to the user independent of the currently set user area. A USER command allowed the user area to be changed to any area from 0 to 15. User 0 was the default. If one changed to another user, such as USER 1, the material saved on the disk for this user would only be available to USER 1; USER 2 would not be able to see it or access it. However, files stored in the USER 0 area were accessible to all other users; their location was specified with a prefatory [[Path (computing)|path]], since the files of USER 0 were only visible to someone logged in as USER 0. The user area feature arguably had little utility on small floppy disks, but it was useful for organizing files on machines with [[hard drive]]s. The intent of the feature was to ease use of the same computer for different tasks. For example, a secretary could do [[data entry clerk|data entry]], then, after switching USER areas, another employee could use the machine to do [[Invoice|billing]] without their files intermixing.

==={{anchor|TPA}}Transient Program Area===
The read/write memory between address 0100 hexadecimal and the lowest address of the BDOS was the ''Transient Program Area'' (TPA) available for CP/M application programs. Although all Z80 and 8080 processors could address 64 kilobytes of memory, the amount available for application programs could vary, depending on the design of the particular computer. Some computers used large parts of the address space for such things as BIOS ROMs, or video display memory. As a result, some systems had more TPA memory available than others. Bank switching was a common technique that allowed systems to have a large TPA while switching out ROM or video memory space as needed. CP/M&amp;nbsp;3.0 allowed parts of the BDOS to be in bank-switched memory as well.

===Debugging application===
CP/M came with a Dynamic Debugging Tool, nicknamed [[Dynamic debugging technique|DDT]] (after the insecticide, i.e. a [[Software bug|bug]]-killer), which allowed memory and program modules to be examined and manipulated, and allowed a program to be executed one step at a time.&lt;ref name=&quot;DDT1&quot;/&gt;&lt;ref name=&quot;DDT2&quot;/&gt;&lt;ref name=&quot;DDT3&quot;/&gt;

==={{anchor|RSX|RSM}}Resident programs===
CP/M originally did not support the equivalent of [[terminate and stay resident]] (TSR) programs as under DOS. Programmers could write software that could intercept certain operating system calls and extend or alter their functionality. Using this capability, programmers developed and sold auxiliary [[desk accessory]] programs, such as [[SmartKey]], a keyboard utility to assign any string of bytes to any key.&lt;ref name=&quot;Software_Catalog_1984&quot;/&gt;
CP/M&amp;nbsp;3, however, added support for [[dynamic loading|dynamically loadable]] ''Resident System Extensions'' (RSX).&lt;ref name=&quot;CPM3_1983_PG&quot;/&gt; Similar solutions like RSMs (for ''Resident System Modules'') were also retrofitted to CP/M&amp;nbsp;2.2 systems by third-parties.&lt;ref name=&quot;ct_1&quot;/&gt;&lt;ref name=&quot;ct_2&quot;/&gt;&lt;ref name=&quot;Huck_2016&quot;/&gt;

===Installation===
Although CP/M provided some [[hardware abstraction]] to standardize the interface to disk I/O or console I/O, typically application programs still required installation to make use of all the features of such equipment as printers and terminals. Often these were controlled by [[escape sequence]]s which had to be altered for different devices. For example, the escape sequence to select bold face on a printer would have differed among manufacturers, and sometimes among models within a manufacturer's range. This procedure was not defined by the operating system; a user would typically run an installation program that would either allow selection from a range of devices, or else allow feature-by-feature editing of the escape sequences required to access a function. This had to be repeated for each application program, since there was no central operating system service provided for these devices.

The initializing codes for each model of printer had to be written into the application. To use a program such as Wordstar with more than one printer (say, a fast dot matrix printer or a slower but presentation-quality [[daisy wheel]] printer), a separate version of Wordstar had to be prepared, and one had to load the Wordstar version that corresponded to the printer selected (and exiting and reloading to change printers).

==History==
[[File:CP⁄M Ad, InfoWorld, November 29, 1982.jpg|thumbnail|right|CP/M advertisement in the 29 November 1982 issue of ''[[InfoWorld]]'' magazine]]

==={{anchor|1.0|1.1|1.2|1.3|1.4}}The beginning and CP/M's heyday===
[[Gary Kildall]] originally developed CP/M during 1974,&lt;ref name=&quot;Shustek_2016&quot;/&gt;&lt;ref name=&quot;Kildall_1993&quot;/&gt; as an operating system to run on an [[Intel]] [[Intellec|Intellec-8]] development system, equipped with a [[Shugart Associates]] 8-inch [[floppy disk drive]] interfaced via a custom [[floppy disk controller]].&lt;ref name=&quot;Kildall_1980_CPM&quot;/&gt; It was written in Kildall's own [[PL/M]] (''[[Programming Language]] for Microcomputers'').&lt;ref name=&quot;Kildall_1975_BDOS&quot;/&gt; Various aspects of CP/M were influenced by the [[TOPS-10]] operating system of the [[DECsystem-10]] [[mainframe computer]], which Kildall had used as a development environment.&lt;ref name=&quot;johnson&quot;/&gt;&lt;ref name=&quot;Dr. Dobb's Journal Apr 1976&quot;/&gt;&lt;ref name=&quot;Digital Research (Firm)&quot;/&gt;

====The name====
CP/M originally stood for &quot;Control Program/Monitor&quot;,&lt;ref name=&quot;CPM.NYT83&quot;/&gt; a name which implies a [[resident monitor]]—a primitive precursor to the operating system. However, during the conversion of CP/M to a commercial product, trademark registration documents filed in November 1977 gave the product's name as &quot;Control Program for Microcomputers&quot;.&lt;ref name=&quot;Kildall_1993&quot;/&gt; The CP/M name follows a prevailing naming scheme of the time, as in Kildall's PL/M language, and Prime Computer's [[PL/P]] (''Programming Language for Prime''), both suggesting IBM's [[PL/I]]; and IBM's [[CP/CMS]] operating system, which Kildall had used when working at the [[Naval Postgraduate School]] (NPS).

This renaming of CP/M was part of a larger effort by Kildall and his wife/business partner, Dorothy McEwen&lt;ref name=&quot;Kildall.NYT&quot;/&gt; to convert Kildall's personal project of CP/M and the Intel-contracted PL/M compiler into a commercial enterprise. The Kildalls intended to establish the Digital Research brand and its product lines as synonymous with &quot;microcomputer&quot; in the consumer's mind, similar to what IBM and Microsoft together later successfully accomplished in making &quot;personal computer&quot; synonymous with their product offerings.

Intergalactic Digital Research, Inc. was later renamed via a corporation change-of-name filing to Digital Research, Inc.&lt;ref name=&quot;Kildall.NYT&quot;/&gt;

====Portability====
By September 1981 Digital Research had sold more than {{val|250000}} CP/M licenses; ''[[InfoWorld]]'' stated that the actual market was likely larger because of sublicenses. Many different companies produced CP/M-based computers for many different markets; the magazine stated that &quot;CP/M is well on its way to establishing itself as ''the'' small-computer operating system&quot;.{{r|hogan19810914state}}
The companies chose to support CP/M because of its large library of software. The [[Xerox 820]] ran the operating system because &quot;where there are literally thousands of programs written for it, it would be unwise not to take advantage of it&quot;, Xerox said.&lt;ref name=&quot;wise19820510&quot;/&gt; (Xerox included a [[Howard W. Sams]] CP/M manual as compensation for Digital Research's documentation, which ''InfoWorld'' in 1982 described as atrocious.&lt;ref name=&quot;meyer19820614&quot;/&gt;) By 1984 [[Columbia University]] used the same source code to build [[Kermit (protocol)|Kermit]] binaries for more than a dozen different CP/M systems, plus a generic version.&lt;ref name=&quot;dacruz19840427&quot;/&gt; The operating system was described as a &quot;[[software bus]]&quot;, allowing multiple programs to interact with different hardware in a standardized way.&lt;ref name=&quot;Swaine_1997_Entrepreneurship&quot;/&gt; Programs written for CP/M were typically portable among different machines, usually requiring only the specification of the [[escape sequence]]s for control of the [[computer terminal|screen]] and printer. This portability made CP/M popular, and much more software was written for CP/M than for operating systems that ran on only one brand of hardware. One restriction on portability was that certain programs used the extended instruction set of the Z80 processor and would not operate on an 8080 or 8085 processor. Another was graphics routines, especially in games and graphics programs, which were generally machine-specific as they used direct hardware access for speed, bypassing the OS and BIOS (this was also a common problem in early DOS machines).{{citation needed|date=August 2017|reason=Certainly a common problem for DOS programs, but CP/M programs typically were more configurable and thus less machine-specific. Therefore this needs to be sourced by a RS.}}

[[File:M Karte.JPG|thumb|right|Apple ''CP/M Card'' with manual]]
[[Bill Gates]] claimed that the [[Apple II family]] with a [[Z-80 SoftCard]] was the single most-popular CP/M hardware platform.&lt;ref name=&quot;bunnell19820203&quot;/&gt; Many different brands of machines ran the operating system, some notable examples being the [[Altair 8800]], the [[IMSAI 8080]], the [[Osborne 1]] and Kaypro [[luggable]]s, and [[MSX]] computers. The best-selling CP/M-capable system of all time was probably the [[Amstrad PCW]]. In the UK, CP/M was also available on [[Research Machines]] educational computers (with the CP/M source code published as an educational resource), and for the [[BBC Micro]] when equipped with a Z80 co-processor. Furthermore, it was available for the [[Amstrad CPC]] series, the [[Commodore 128]], [[TRS-80]], and later models of the [[ZX Spectrum]]. CP/M&amp;nbsp;3 was also used on the NIAT, a custom handheld computer designed for [[A.C. Nielsen]]'s internal use with 1&amp;nbsp;[[megabyte|MB]] of [[Solid-state drive|SSD]] memory.

====Applications====
[[File:Wordstar 4 CPM.jpg|thumb|right|Distribution 5 1/4 inch diskettes and packaging for the last version (Version 4) of [[WordStar]] word processing program released for 8-bit CP/M.]]
[[WordStar]], one of the first widely used [[word processor]]s, and [[dBase]], an early and popular database program for microcomputers, were originally written for CP/M. Two early [[outliner]]s, [[KAMAS (program)|KAMAS]] (Knowledge and Mind Amplification System) and its cut-down successor Out-Think (without programming facilities and retooled for 8080/V20 compatibility) were also written for CP/M, though later rewritten for MS-DOS. [[Turbo Pascal]], the ancestor of [[Borland Delphi]], and [[Multiplan]], the ancestor of [[Microsoft Excel]], also debuted on CP/M before MS-DOS versions became available. [[Visicalc]], the first-ever spreadsheet program, was made available for CP/M. Another company, [[Sorcim]], created its [[SuperCalc]] spreadsheet for CP/M, which would go on to become the market leader and de facto standard on CP/M. Supercalc would go on to be a competitor in the spreadsheet market in the MS-DOS world. [[AutoCAD]], a CAD application from Autodesk debuted on CP/M. A host of compilers and interpreters for popular [[programming language]]s of the time (such as [[BASIC]], [[Borland]]'s [[Turbo Pascal]], [[FORTRAN]] and even [[PL/I]]&lt;ref name=&quot;PL1&quot;/&gt;) were available, among them several of the earliest [[Microsoft]] products.

CP/M software often came with [[installer]]s that adapted it to a wide variety of computers.&lt;ref name=&quot;mace19840109_16&quot;/&gt; The source code for BASIC programs was easily accessible, and most forms of [[copy protection]] were ineffective on the operating system.&lt;ref name=&quot;pournelle198306&quot;/&gt; A Kaypro II owner, for example, would obtain software on Xerox 820 format, then copy it to and run it from Kaypro-format disks.{{r|derfler19821018}}

The lack of standardized graphics support limited [[video games]], but various character and text-based games were [[ported]], such as ''[[Telengard]]'',&lt;ref name=&quot;loguidice20120728&quot;/&gt; ''[[Gorillas (video game)|Gorillas]]'',&lt;ref name=&quot;githubgorilla001&quot;/&gt; ''[[Hamurabi (video game)|Hamurabi]]'', ''[[Lunar Lander (video game series)|Lunar Lander]]'', along with early [[interactive fiction]] including the [[Zork]] series and ''[[Colossal Cave Adventure]]''. A [[text adventure]] specialist, [[Infocom]] was one of the few publishers to consistently release their games in CP/M format. [[Lifeboat Associates]] started collecting and distributing user-written &quot;free&quot; software. One of the first was [[XMODEM]], which allowed reliable file transfers via [[modem]] and phone line. Another program native to CP/M was the [[outline processor]] [[KAMAS (program)|KAMAS]].{{citation needed|date=September 2016}}

====Disk formats====
[[IBM System/34]] and [[IBM 3740]]'s single-density, single-sided format is CP/M's standard 8-inch [[floppy disk format]]. No standard 5.25-inch CP/M disk format exists, with Kaypro, [[Morrow Designs]], Osborne, and others using their own.&lt;ref name=&quot;pournelle198204&quot;/&gt;{{r|meyer19820614}}&lt;ref name=&quot;128book&quot;/&gt; ''InfoWorld'' estimated in September 1981 that &quot;about two dozen formats were popular enough that software creators had to consider them to reach the broadest possible market&quot;.&lt;ref name=&quot;hogan19810914state&quot;/&gt; [[JRT Pascal]], for example, provided versions on 5.25-inch disk for [[North Star Computers|North Star]], Osborne, Apple, [[Zenith Data Systems|Heath]] [[hard sector]] and [[soft sector]], and [[Superbrain]], and one 8-inch version.&lt;ref name=&quot;byte198212&quot;/&gt; Ellis Computing also offered its software for both Heath formats, and 16 other 5.25-inch formats including two different TRS-80 CP/M modifications.&lt;ref name=&quot;byte198312&quot;/&gt;

Certain disk formats were more popular than others. Most software was available in the Xerox 820 format, and other computers such as the Kaypro II were compatible with it.&lt;ref name=&quot;derfler19821018&quot;/&gt;&lt;ref name=&quot;byte198309&quot;/&gt; No single manufacturer, however, prevailed in the 5.25-inch era of CP/M use, and disk formats were often not portable between hardware manufacturers. A software manufacturer had to prepare a separate version of the program for each brand of hardware on which it was to run. With some manufacturers (Kaypro is an example), there was not even standardization across the company's different models. Because of this situation, disk format translation programs, which allowed a machine to read many different formats, became popular and reduced the confusion, as did programs like Kermit which allowed transfer of data and programs from one machine to another using the [[RS-232|serial]] ports that most CP/M machines had.

Various formats were used depending on the characteristics of particular systems and to some degree the choices of the designers. CP/M supported options to control the size of reserved and directory areas on the disk, and the mapping between logical disk sectors (as seen by CP/M programs) and physical sectors as allocated on the disk. There were many ways to customize these parameters for every system&lt;ref name=&quot;Johnson-Laird_1983&quot;/&gt; but once they had been set, no standardized way existed for a system to load parameters from a disk formatted on another system.

The degree of portability between different CP/M machines depended on the type of disk drive and controller used since many different floppy types existed in the CP/M era in both 8-inch and 5.25-inch format. Disks could be hard or soft sectored, single or double density, single or double sided, 35 track, 40 track, 77 track, or 80 track, and the sector layout, size and interleave could vary widely as well. Although translation programs could allow the user to read disk types from different machines, it also depended on the drive type and controller. By 1982, soft sector, single sided, 40 track 5.25-inch disks had become the most popular format to distribute CP/M software on as they were used by the most common consumer-level machines of that time such as the Apple II, TRS-80, Osborne 1, Kaypro II, and IBM PC. A translation program allowed the user to read any disks on his machine that had a similar format—for example, the Kaypro II could read [[TRS-80]], [[Osborne 1|Osborne]], [[IBM PC]], and [[Epson QX-10|Epson]] disks. Other disk types such as 80 track or hard sectored were completely impossible to read. The first half of double sided disks (like the Epson QX-10's) could be read because CP/M accessed disk tracks sequentially with track 0 being the first (outermost) track of side 1 and track 79 (on a 40 track disk) being the last (innermost) track of side 2. Apple II users could not use anything but Apple's GCR format and so had to obtain CP/M software on Apple format disks or else transfer it via serial link.

The fragmented CP/M market, requiring distributors either to stock multiple formats of disks or to invest in multiformat duplication equipment, compared with the more standardized [[IBM PC]] disk formats, was a contributing factor to the rapid obsolescence of CP/M after 1981.

One of the last notable CP/M capable machines to appear was the [[Commodore&amp;nbsp;128]] in 1985, which had a Z80 for CP/M support in addition to its native mode using a 6502-derivative CPU. Using CP/M required either a [[Commodore 1571|1571]] or [[Commodore 1581|1581]] disk drive which could read soft sector 40 track [[Modified Frequency Modulation|MFM]] format disks.

The first computer to use a 3.5-inch floppy drive, the [[Sony SMC-70]],&lt;ref name=&quot;Sony-SMC-70&quot;/&gt; ran CP/M&amp;nbsp;2.2. The [[Commodore 128]], [[Bondwell-2]] laptop, Micromint/Ciarcia SB-180,&lt;ref name=&quot;Ciarcia_1985&quot;/&gt; [[MSX]] and [[TRS-80 Model&amp;nbsp;4]] (running Montezuma CP/M&amp;nbsp;2.2) also supported the use of CP/M with 3.5-inch floppy disks. The [[Amstrad PCW]] ran CP/M using 3 inch floppy drives at first, and later switched to the 3.5 inch drives.

====Graphics====
[[File:MBasic 5.21.jpg|thumb|[[MBASIC]] text output displayed on a monochrome monitor typical for that time.]]
Although graphics-capable S-100 systems existed from the commercialization of the [[S-100 bus]], CP/M did not provide any standardized graphics support until 1982 with [[Graphics System Extension|GSX]] (Graphics System Extension). Owing to the small memory available, graphics was never a common feature associated with 8-bit CP/M operating systems. Most systems could only display rudimentary [[ASCII art]] charts and diagrams in [[text mode]] or by using a custom [[character set]]. Some computers in the [[Kaypro#Kaypro computers|Kaypro]] line and the [[TRS-80 Model 4]] had video hardware supporting block graphics characters, and these were accessible to assembler programmers and BASIC programmers using the CHR$ command. The Model 4 could display 640 by 240 pixel graphics with an optional high resolution board.
