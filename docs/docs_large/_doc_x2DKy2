The idea of being able to simulate the ASICs from the information in this documentation was so obviously attractive that [[Logic simulation|logic simulators]] were developed that could read the VHDL files. The next step was the development of [[logic synthesis]] tools that read the VHDL and output a definition of the physical implementation of the circuit.

Due to the Department of Defense requiring as much of the syntax as possible to be based on Ada, in order to avoid re-inventing concepts that had already been thoroughly tested in the development of Ada,{{citation needed|date=November 2010}} VHDL borrows heavily from the [[Ada (programming language)|Ada programming language]] in both concept and [[syntax]].

The initial version of VHDL, designed to [[IEEE]] standard IEEE 1076-1987,&lt;ref name=&quot;originalversion&quot;&gt;{{Cite book| title = 1076-1987 – IEEE Standard VHDL Language Reference Manual| doi = 10.1109/IEEESTD.1988.122645| year = 1988| isbn = 0-7381-4324-3}}&lt;/ref&gt; included a wide range of data types, including numerical ([[integer]] and [[real data type|real]]), logical ([[bit]] and [[Boolean datatype|boolean]]), [[character (computing)|character]] and [[time]], plus [[Array data type|arrays]] of &lt;code&gt;bit&lt;/code&gt; called &lt;code&gt;bit_vector&lt;/code&gt; and of &lt;code&gt;character&lt;/code&gt; called [[string (computer science)|string]].

A problem not solved by this edition, however, was &quot;multi-valued logic&quot;, where a signal's [[drive strength]] (none, weak or strong) and unknown values are also considered. This required [[IEEE 1164|IEEE standard 1164]], which defined the 9-value logic types: scalar &lt;code&gt;std_logic&lt;/code&gt; and its vector version &lt;code&gt;std_logic_vector&lt;/code&gt;. Being a resolved subtype of its &lt;code&gt;std_Ulogic&lt;/code&gt; parent type, &lt;code&gt;std_logic&lt;/code&gt;-typed signals allow multiple driving for modeling bus structures, whereby the connected resolution function handles conflicting assignments adequately.

The updated [[IEEE 1076]], in 1993, made the syntax more consistent, allowed more flexibility in naming, extended the &lt;code&gt;character&lt;/code&gt; type to allow [[ISO-8859-1]] printable characters, added the &lt;code&gt;xnor&lt;/code&gt; operator, etc.{{specify|date=November 2010}}

Minor changes in the standard (2000 and 2002) added the idea of protected types (similar to the concept of class in C++) and removed some restrictions from port mapping rules.

In addition to IEEE standard 1164, several child standards were introduced to extend functionality of the language. IEEE standard 1076.2 added better handling of real and complex data types. IEEE standard 1076.3 introduced [[Signedness|signed and unsigned]] types to facilitate arithmetical operations on vectors. IEEE standard 1076.1 (known as [[VHDL-AMS]]) provided analog and mixed-signal circuit design extensions.

Some other standards support wider use of VHDL, notably [[VHDL-VITAL|VITAL]] (VHDL Initiative Towards ASIC Libraries) and [[microwave]] circuit design extensions.

In June 2006, the VHDL Technical Committee of [[Accellera]] (delegated by IEEE to work on the next update of the standard) approved so-called Draft 3.0 of VHDL-2006. While maintaining full compatibility with older versions, this proposed standard provides numerous extensions that make writing and managing VHDL code easier. Key changes include incorporation of child standards (1164, 1076.2, 1076.3) into the main 1076 standard, an extended set of operators, more flexible syntax of ''case'' and ''generate'' statements, incorporation of VHPI (VHDL Procedural Interface) (interface to C/C++ languages) and a subset of PSL ([[Property Specification Language]]). These changes should improve quality of synthesizable VHDL code, make testbenches more flexible, and allow wider use of VHDL for system-level descriptions.

In February 2008, Accellera approved VHDL 4.0, also informally known as VHDL 2008, which addressed more than 90 issues discovered during the trial period for version 3.0 and includes enhanced generic types. In 2008, Accellera released VHDL 4.0 to the IEEE for balloting for inclusion in IEEE 1076-2008. The VHDL standard IEEE 1076-2008&lt;ref&gt;{{Cite book |title = 1076-2008 – IEEE Standard VHDL Language Reference Manual |doi = 10.1109/IEEESTD.2009.4772740 |year = 2009 |isbn = 978-0-7381-6854-8}}&lt;/ref&gt; was published in January 2009.

===Standardization===
The [[IEEE]] Standard 1076 defines the [[VHSIC]] [[Hardware Description Language]], or VHDL. It was originally developed under contract F33615-83-C-1003 from the [[United States Air Force]] awarded in 1983 to a team of Intermetrics, Inc. as language experts and prime contractor, [[Texas Instruments]] as chip design experts and [[IBM]] as computer-system design experts. The language has undergone numerous revisions and has a variety of sub-standards associated with it that augment or extend it in important ways.

1076 was and continues to be a milestone in the design of electronic systems.{{citation needed |date= August 2011}}

====Revisions====
* IEEE 1076-1987&lt;ref name=&quot;originalversion&quot; /&gt; First standardized revision of ver 7.2 of the language from the United States Air Force.
* IEEE 1076-1993&lt;ref&gt;{{Cite book |title = 1076-1993 – IEEE Standard VHDL Language Reference Manual |doi = 10.1109/IEEESTD.1994.121433 |year = 1994 |isbn = 0-7381-0986-X}}&lt;/ref&gt; (also published with {{ISBN|1-55937-376-8}}). Significant improvements resulting from several years of feedback. Probably the most widely used version with the greatest vendor tool support.
* IEEE 1076-2000.&lt;ref&gt;{{Cite book |title = 1076-2000 – IEEE Standard VHDL Language Reference Manual |doi = 10.1109/IEEESTD.2000.92297 |year = 2000 |isbn = 0-7381-1948-2}}&lt;/ref&gt; Minor revision. Introduces the use of ''protected types''.
* IEEE 1076-2002.&lt;ref&gt;{{Cite book |title = 1076-2002 – IEEE Standard VHDL Language Reference Manual |doi = 10.1109/IEEESTD.2002.93614 |year = 2002 |isbn = 0-7381-3247-0}}&lt;/ref&gt; Minor revision of 1076-2000. Rules with regard to ''buffer ports'' are relaxed.
** IEC 61691-1-1:2004.&lt;ref&gt;{{Cite book |doi = 10.1109/IEEESTD.2004.95752 |title = IEC 61691-1-1 First edition 2004-10; IEEE 1076 — IEC/IEEE Behavioural Languages – Part 1-1: VHDL Language Reference Manual (Adoption of IEEE Std 1076-2002) |year = 2004 |isbn = 2-8318-7691-5}}&lt;/ref&gt; IEC adoption of IEEE 1076-2002.
* IEEE 1076-2008&lt;ref&gt;{{Cite book |title = 1076c-2007 – IEEE Standard VHDL Language Reference Manual Amendment 1: Procedural Language Application Interface |doi = 10.1109/IEEESTD.2007.4299594 |year = 2007 |isbn = 978-0-7381-5523-4}}&lt;/ref&gt; (previously referred to as 1076-200x). Major revision released on 2009-01-26. Among other changes, this standard incorporates a basic subset of PSL, allows for generics on packages and subprograms and introduces the use of ''external names''.
** IEC 61691-1-1:2011.&lt;ref&gt;{{Cite book |doi = 10.1109/IEEESTD.2011.5967868 |title = 61691-1-1-2011 — Behavioural languages – Part 1-1: VHDL Language Reference Manual |year = 2011 |isbn = 978-0-7381-6605-6}}&lt;/ref&gt; IEC adoption of IEEE 1076-2008.

====Related standards====
* IEEE 1076.1 VHDL Analog and Mixed-Signal ([[VHDL-AMS]])
* IEEE 1076.1.1 VHDL-AMS Standard Packages (stdpkgs)
* IEEE 1076.2 VHDL Math Package
* IEEE 1076.3 VHDL Synthesis Package (vhdlsynth) ([[numeric_std]])
* IEEE 1076.3 VHDL Synthesis Package – Floating Point (fphdl)
* IEEE 1076.4 Timing (VHDL Initiative Towards ASIC Libraries: vital)
* IEEE 1076.6 VHDL Synthesis Interoperability (withdrawn in 2010)&lt;ref&gt;https://standards.ieee.org/standard/1076_6-2004.html&lt;/ref&gt;
* [[IEEE 1164]] VHDL Multivalue Logic (std_logic_1164) Packages

==Design==
VHDL is generally used to write text models that describe a logic circuit. Such a model is processed by a synthesis program, only if it is part of the logic design. A simulation program is used to test the logic design using simulation models to represent the logic circuits that interface to the design. This collection of simulation models is commonly called a ''testbench''.

A VHDL simulator is typically an [[event-driven simulator]].&lt;ref&gt;{{cite web|title=ELEC3017 - Simulation|url=http://users.ecs.soton.ac.uk/mz/elec3017/vhdlsim.pdf|publisher=University of Southampton|accessdate=23 February 2017}}&lt;/ref&gt; This means that each transaction is added to an event queue for a specific scheduled time. E.g. if a signal assignment should occur after 1 nanosecond, the event is added to the queue for time +1ns. Zero delay is also allowed, but still needs to be scheduled: for these cases [[Delta delay]] is used, which represent an infinitely small time step. The simulation alters between two modes: statement execution, where triggered statements are evaluated, and event processing, where events in the queue are processed.

VHDL has constructs to handle the [[parallel computing|parallelism]] inherent in hardware designs, but these constructs (''processes'') differ in syntax from the parallel constructs in Ada (''tasks''). Like Ada, VHDL is [[strongly typed]] and is [[Case sensitivity|not case sensitive]]. In order to directly represent operations which are common in hardware, there are many features of VHDL which are not found in Ada, such as an extended set of Boolean operators including '''nand''' and '''nor'''.

VHDL has file input and output capabilities, and can be used as a general-purpose language for text processing, but files are more commonly used by a simulation testbench for stimulus or verification data. There are some VHDL compilers which build executable binaries. In this case, it might be possible to use VHDL to write a ''testbench'' to verify the functionality of the design using files on the host computer to define stimuli, to interact with the user, and to compare results with those expected. However, most designers leave this job to the simulator.

It is relatively easy for an inexperienced developer to produce code that simulates successfully but that cannot be synthesized into a real device, or is too large to be practical. One particular pitfall is the accidental production of [[transparent latch]]es rather than [[Flip-flop (electronics)#D flip-flop|D-type flip-flops]] as storage elements.&lt;ref&gt;{{cite web|title=Why should I care about Transparent Latches?|url=http://www.doulos.com/knowhow/fpga/latches/|publisher=Doulos|accessdate=22 December 2012}}&lt;/ref&gt;

One can design hardware in a VHDL IDE (for FPGA implementation such as Xilinx ISE, Altera Quartus, Synopsys Synplify or Mentor Graphics HDL Designer) to produce the [[Register-transfer level|RTL]] schematic of the desired circuit. After that, the generated schematic can be verified using simulation software which shows the waveforms of inputs and outputs of the circuit after generating the appropriate testbench. To generate an appropriate testbench for a particular circuit or VHDL code, the inputs have to be defined correctly. For example, for clock input, a loop process or an iterative statement is required.&lt;ref&gt;{{cite web|title=Clock Generation|url=http://www.doulos.com/knowhow/vhdl_designers_guide/tips/clock_generation/|publisher=Doulos|accessdate=22 December 2012}}&lt;/ref&gt;

A final point is that when a VHDL model is translated into the &quot;gates and wires&quot; that are mapped onto a programmable logic device such as a [[CPLD]] or [[FPGA]], then it is the actual hardware being configured, rather than the VHDL code being &quot;executed&quot; as if on some form of a processor chip.

==Advantages==
The key advantage of VHDL, when used for systems design, is that it allows the behavior of the required system to be described (modeled) and verified (simulated) before synthesis tools translate the design into real hardware (gates and wires).

Another benefit is that VHDL allows the description of a [[concurrent system]]. VHDL is a [[Dataflow programming|dataflow language]] in which every statement is considered for execution simultaneously, unlike procedural computing languages such as BASIC, C, and assembly code, where a sequence of statements is run sequentially one instruction at a time.

A VHDL project is multipurpose. Being created once, a calculation block can be used in many other projects. However, many formational and functional block parameters can be tuned (capacity parameters, memory size, element base, block composition and interconnection structure).

A VHDL project is portable. Being created for one element base, a computing device project can be ported on another element base, for example [[VLSI]] with various technologies.

A big advantage of VHDL compared to original [[Verilog]] is that VHDL has a full [[type system]]. Designers can use the type system to write much more structured code (especially by declaring [[Record (computer science)|record]] types).&lt;ref&gt;{{cite web |url=http://gaisler.com/doc/structdesign.pdf |accessdate=15 November 2017 |title=A structured VHDL Design Method |author=Jiri Gaisler}}&lt;/ref&gt;

==Design examples==
{{manual|section|date=January 2013}}
In VHDL, a design consists at a minimum of an ''entity'' which describes the interface and an ''architecture'' which contains the actual implementation. In addition, most designs import library modules. Some designs also contain multiple architectures and ''configurations''.

A simple [[Logic gate|AND gate]] in VHDL would look something like
&lt;syntaxhighlight lang=&quot;vhdl&quot;&gt;
-- (this is a VHDL comment)
/*
    this is a block comment (VHDL-2008)
*/
-- import std_logic from the IEEE library
library IEEE;
use IEEE.std_logic_1164.all;

-- this is the entity
entity ANDGATE is
  port ( 
    I1 : in std_logic;
    I2 : in std_logic;
    O  : out std_logic);
end entity ANDGATE;

-- this is the architecture
architecture RTL of ANDGATE is
begin
  O &lt;= I1 and I2;
end architecture RTL;
&lt;/syntaxhighlight&gt;

(Notice that &lt;code&gt;RTL&lt;/code&gt; stands for ''[[Register transfer level]]'' design.) While the example above may seem verbose to HDL beginners, many parts are either optional or need to be written only once. Generally simple functions like this are part of a larger behavioral module, instead of having a separate module for something so simple. In addition, use of elements such as the &lt;code&gt;std_logic&lt;/code&gt; type might at first seem to be an overkill. One could easily use the built-in &lt;code&gt;bit&lt;/code&gt; type and avoid the library import in the beginning. However, using a form of [[many-valued logic]], specifically [[IEEE 1164|9-valued logic]] (&lt;code&gt;U&lt;/code&gt;,&lt;code&gt;X&lt;/code&gt;,&lt;code&gt;0&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;Z&lt;/code&gt;,&lt;code&gt;W&lt;/code&gt;,&lt;code&gt;H&lt;/code&gt;,&lt;code&gt;L&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;), instead of simple bits (0,1) offers a very powerful simulation and debugging tool to the designer which currently does not exist in any other HDL.

In the examples that follow, you will see that VHDL code can be written in a very compact form. However, more experienced designers usually avoid these compact forms and use a more verbose coding style for the sake of readability and maintainability. Another advantage to the verbose coding style is the smaller amount of resources used when programming to a Programmable Logic Device such as a CPLD.&lt;ref&gt;{{cite book |last1=McConnell |first1=Steve |title=Code Complete |date=2004 |publisher=Pearson Education |pages=319–320 |edition=2}}&lt;/ref&gt;

===Synthesizable constructs and VHDL templates===
VHDL is frequently used for two different goals: simulation of electronic designs and synthesis of such designs. Synthesis is a process where a VHDL is compiled and mapped into an implementation technology such as an FPGA or an ASIC. Many FPGA vendors have free (or inexpensive) tools for synthesizing VHDL to use with their chips, where ASIC tools are often very expensive.

Not all constructs in VHDL are suitable for synthesis. For example, most constructs that explicitly deal with timing such as &lt;code&gt;wait for 10 ns;&lt;/code&gt; are not synthesizable despite being valid for simulation. While different synthesis tools have different capabilities, there exists a common ''synthesizable subset'' of VHDL that defines what language constructs and idioms map into common hardware for many synthesis tools. IEEE 1076.6 defines a subset of the language that is considered the official synthesis subset. It is generally considered a &quot;best practice&quot; to write very idiomatic code for synthesis as results can be incorrect or suboptimal for non-standard constructs.

===MUX template===
The [[multiplexer]], or 'MUX' as it is usually called, is a simple construct very common in hardware design. The example below demonstrates a simple two to one MUX, with inputs &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, selector &lt;code&gt;S&lt;/code&gt; and output &lt;code&gt;X&lt;/code&gt;. Note that there are many other ways to express the same MUX in VHDL.&lt;ref&gt;{{cite web |url=https://www.fpgatutorial.com/vhdl-logical-operators-and-signal-assignments-for-combinatorial-logic/#vhdl-mux |title=VHDL Logical Operators and Signal Assignments for Combinatorial Logic |website=FPGAtutorial |access-date=2020-08-23}}&lt;/ref&gt;
&lt;syntaxhighlight lang=&quot;VHDL&quot;&gt;X &lt;= A when S = '1' else B;&lt;/syntaxhighlight&gt;

===Latch template===
A [[transparent latch]] is basically one bit of memory which is updated when an enable signal is raised. Again, there are many other ways this can be expressed in VHDL.
&lt;syntaxhighlight lang=&quot;vhdl&quot;&gt;
-- latch template 1:
Q &lt;= D when Enable = '1' else Q;

-- latch template 2:
process(all)
begin
    Q &lt;= D when(Enable);
end process;
&lt;/syntaxhighlight&gt;

===D-type flip-flops===
The D-type [[Flip-flop (electronics)|flip-flop]] samples an incoming signal at the rising (or falling) edge of a clock. This example has an asynchronous, active-high reset, and samples at the rising clock edge.
&lt;syntaxhighlight lang=&quot;vhdl&quot;&gt;
DFF : process(all) is
begin
  if RST then
    Q &lt;= '0';
  elsif rising_edge(CLK) then
    Q &lt;= D;
  end if;
end process DFF;
&lt;/syntaxhighlight&gt;

Another common way to write edge-triggered behavior in VHDL is with the 'event' signal attribute. A single apostrophe has to be written between the signal name and the name of the attribute.
&lt;syntaxhighlight lang=&quot;vhdl&quot;&gt;
DFF : process(RST, CLK) is
begin
  if RST then
    Q &lt;= '0';
  elsif CLK'event and CLK = '1' then
    Q &lt;= D;
  end if;
end process DFF;
&lt;/syntaxhighlight&gt;

VHDL also lends itself to &quot;one-liners&quot; such as
&lt;syntaxhighlight lang=&quot;VHDL&quot;&gt;
DFF : Q &lt;= '0' when RST = '1' else D when rising_edge(clk);
&lt;/syntaxhighlight&gt;

or

&lt;syntaxhighlight lang=&quot;vhdl&quot;&gt;
DFF : process(all) is 
begin
  if rising_edge(CLK) then
    Q  &lt;= D;
    Q2 &lt;= Q1;
  end if;
  if RST then
    Q &lt;= '0';
  end if;
end process DFF;
&lt;/syntaxhighlight&gt;

Which can be useful if not all signals (registers) driven by this process should be reset.

===Example: a counter===
The following example is an up-counter with asynchronous reset, parallel load and configurable width. It demonstrates the use of the 'unsigned' type, type conversions between 'unsigned' and 'std_logic_vector' and VHDL ''generics''. The generics are very close to arguments or templates in other traditional programming languages like C++.
&lt;syntaxhighlight lang=&quot;vhdl&quot;&gt;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;    -- for the unsigned type

entity COUNTER is
  generic (
    WIDTH : in natural := 32);
  port (
    RST   : in std_logic;
    CLK   : in std_logic;
    LOAD  : in std_logic;
    DATA  : in std_logic_vector(WIDTH-1 downto 0);
    Q     : out std_logic_vector(WIDTH-1 downto 0));
end entity COUNTER;

architecture RTL of COUNTER is

begin
  process(all) is
  begin
    if RST then
      Q &lt;= (others =&gt; '0');
    elsif rising_edge(CLK) then
      if LOAD then
        Q &lt;= DATA;
      else
        Q &lt;= std_logic_vector(unsigned(Q) + 1); --Addition is unsigned, converted back to std_logic_vector
      end if;
    end if;
  end process;

end architecture RTL;
&lt;/syntaxhighlight&gt;

More complex counters may add if/then/else statements within the &lt;code&gt;rising_edge(CLK) elsif&lt;/code&gt; to add other functions, such as count enables, stopping or rolling over at some count value, generating output signals like terminal count signals, etc. Care must be taken with the ordering and nesting of such controls if used together, in order to produce the desired priorities and minimize the number of logic levels needed.

===Simulation-only constructs===
A large subset of VHDL cannot be translated into hardware. This subset is known as the non-synthesizable or the simulation-only subset of VHDL and can only be used for prototyping, simulation and debugging. For example, the following code will generate a clock with a frequency of 50&amp;nbsp;MHz. It can, for example, be used to drive a clock input in a design during simulation. It is, however, a simulation-only construct and cannot be implemented in hardware. In actual hardware, the clock is generated externally; it can be scaled down internally by user logic or dedicated hardware.
&lt;syntaxhighlight Lang=&quot;VHDL&quot;&gt;
process
begin
  CLK &lt;= '1'; wait for 10 NS;
  CLK &lt;= '0'; wait for 10 NS;
end process;
&lt;/syntaxhighlight&gt;
