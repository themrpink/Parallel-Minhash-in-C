In practice, the controller accepts the inputs and maps them into their membership functions and truth values. These mappings are then fed into the rules. If the rule specifies an AND relationship between the mappings of the two input variables, as the examples above do, the minimum of the two is used as the combined truth value; if an OR is specified, the maximum is used. The appropriate output state is selected and assigned a membership value at the truth level of the premise. The truth values are then defuzzified. 
For example, assume the temperature is in the &quot;cool&quot; state, and the pressure is in the &quot;low&quot; and &quot;ok&quot; states. The pressure values ensure that only rules 2 and 3 fire:

[[File:Fuzzy control - Rule 2 evaluation.png]]

[[File:Fuzzy control - Rule 3 evaluation.png]]

The two outputs are then defuzzified through centroid defuzzification: 
&lt;pre&gt;
   __________________________________________________________________

                                       |          Z      P2
                                    1 -+          *       *
                                       |         * *     * *
                                       |        *   *   *   *
                                       |       *     * *     *
                                       |      *       222222222
                                       |     *       22222222222
                                       |    333333332222222222222
                                       +---33333333222222222222222--&amp;gt;
                                                        ^ 
                                                      +150 
   __________________________________________________________________
&lt;/pre&gt;

The output value will adjust the throttle and then the control cycle will begin again to generate the next value .

=== Building a fuzzy controller ===
Consider implementing with a microcontroller chip a simple feedback controller:

[[File:Fuzzy control system-feedback controller.png]]

A fuzzy set is defined for the input error variable &quot;e&quot;, and the derived change in error, &quot;delta&quot;, as well as the &quot;output&quot;, as follows:

   LP:  large positive
   SP:  small positive
   ZE:  zero
   SN:  small negative
   LN:  large negative

If the error ranges from -1 to +1, with the analog-to-digital converter used having a resolution of 0.25, then the input variable's fuzzy set (which, in this case, also applies to the output variable) can be described very simply as a table, with the error / delta / output values in the top row and the truth values for each membership function arranged in rows beneath:

   _______________________________________________________________________
 
               -1    -0.75  -0.5   -0.25    0     0.25   0.5    0.75    1
   _______________________________________________________________________
 
    mu(LP)      0      0      0      0      0      0     0.3    0.7     1
    mu(SP)      0      0      0      0     0.3    0.7     1     0.7    0.3
    mu(ZE)      0      0     0.3    0.7     1     0.7    0.3     0      0
    mu(SN)     0.3    0.7     1     0.7    0.3     0      0      0      0
    mu(LN)      1     0.7    0.3     0      0      0      0      0      0
   _______________________________________________________________________            —or, in graphical form (where each &quot;X&quot; has a value of 0.1):

          LN           SN           ZE           SP           LP
       +------------------------------------------------------------------+
       |                                                                  |
 -1.0  |  XXXXXXXXXX   XXX          :            :            :           |
 -0.75 |  XXXXXXX      XXXXXXX      :            :            :           |
 -0.5  |  XXX          XXXXXXXXXX   XXX          :            :           |
 -0.25 |  :            XXXXXXX      XXXXXXX      :            :           |
  0.0  |  :            XXX          XXXXXXXXXX   XXX          :           |
  0.25 |  :            :            XXXXXXX      XXXXXXX      :           |
  0.5  |  :            :            XXX          XXXXXXXXXX   XXX         |
  0.75 |  :            :            :            XXXXXXX      XXXXXXX     |
  1.0  |  :            :            :            XXX          XXXXXXXXXX  |
       |                                                                  |
       +------------------------------------------------------------------+

Suppose this fuzzy system has the following rule base:

   rule 1:  IF e = ZE AND delta = ZE THEN output = ZE
   rule 2:  IF e = ZE AND delta = SP THEN output = SN
   rule 3:  IF e = SN AND delta = SN THEN output = LP
   rule 4:  IF e = LP OR  delta = LP THEN output = LN

These rules are typical for control applications in that the antecedents consist of the logical combination of the error and error-delta signals, while the consequent is a control command output. 
The rule outputs can be defuzzified using a discrete centroid computation:

   SUM( I = 1 TO 4 OF ( mu(I) * output(I) ) ) / SUM( I = 1 TO 4 OF mu(I) )

Now, suppose that at a given time: 
   e     = 0.25
   delta = 0.5

Then this gives:

   ________________________
 
               e     delta
   ________________________
 
   mu(LP)      0      0.3
   mu(SP)     0.7      1
   mu(ZE)     0.7     0.3
   mu(SN)      0       0
   mu(LN)      0       0
   ________________________

Plugging this into rule 1 gives:

   rule 1:  IF e = ZE AND delta = ZE THEN output = ZE
  
      mu(1)     = MIN( 0.7, 0.3 ) = 0.3
      output(1) = 0

-- where:

* mu(1): Truth value of the result membership function for rule 1. In terms of a centroid calculation, this is the &quot;mass&quot; of this result for this discrete case.
* output(1):  Value (for rule 1) where the result membership function (ZE) is maximum over the output variable fuzzy set range. That is, in terms of a centroid calculation, the location of the &quot;center of mass&quot; for this individual result. This value is independent of the value of &quot;mu&quot;. It simply identifies the location of ZE along the output range.

The other rules give:

   rule 2:  IF e = ZE AND delta = SP THEN output = SN
 
      mu(2)     = MIN( 0.7, 1 ) = 0.7   
      output(2) = -0.5

   rule 3: IF e = SN AND delta = SN THEN output = LP
 
      mu(3)     = MIN( 0.0, 0.0 ) = 0
      output(3) = 1

   rule 4: IF e = LP OR  delta = LP THEN output = LN
 
      mu(4)     = MAX( 0.0, 0.3 ) = 0.3
      output(4) = -1

The centroid computation yields:

   &lt;math&gt; \frac{mu(1) \cdot output(1)+mu(2) \cdot output(2)+mu(3) \cdot output(3)+mu(4) \cdot output(4)}{mu(1)+mu(2)+mu(3)+mu(4)} &lt;/math&gt;
   &lt;math&gt;=\frac{(0.3 \cdot 0)+(0.7 \cdot-0.5)+(0 \cdot 1) +(0.3 \cdot-1)}{0.3+0.7+0+0.3} &lt;/math&gt;
   &lt;math&gt;=-0.5&lt;/math&gt;—for the final control output. Simple. Of course the hard part is figuring out what rules actually work correctly in practice.

If you have problems figuring out the centroid equation, remember that a centroid is defined by summing all the moments (location times mass) around the center of gravity and equating the sum to zero. So if &lt;math&gt;X_0&lt;/math&gt; is the center of gravity, &lt;math&gt;X_i&lt;/math&gt; is the location of each mass, and &lt;math&gt;M_i&lt;/math&gt; is each mass, this gives:

   &lt;math&gt;0 = ( X_1 - X_0 ) \cdot M_1 + ( X_2 - X_0 ) \cdot M_2 + \ldots + ( X_n - X_0 ) \cdot M_n&lt;/math&gt;
   &lt;math&gt;0 = ( X_1 \cdot M_1 + X_2 \cdot M_2 + \ldots + X_n \cdot M_n ) - X_0 \cdot ( M_1 + M_2 + \ldots + M_n ) &lt;/math&gt;
   &lt;math&gt; X_0 \cdot ( M_1 + M_2 + \ldots + M_n ) =  X_1 \cdot M_1 + X_2 \cdot M_2 + \ldots + X_n \cdot M_n &lt;/math&gt;
   &lt;math&gt; X_0 = \frac{ X_1 \cdot M_1 + X_2 \cdot M_2 + \ldots + X_n \cdot M_n }{ M_1 + M_2 + \ldots + M_n }&lt;/math&gt;

In our example, the values of mu correspond to the masses, and the values of X to location of the masses  
(mu, however, only 'corresponds to the masses' if the initial 'mass' of the output functions are all the same/equivalent. If they are not the same, i.e. some are narrow triangles, while others maybe wide trapezoids or shouldered triangles, then the mass or area of the output function must be known or calculated. It is this mass that is then scaled by mu and multiplied by its location X_i).

This system can be implemented on a standard microprocessor, but dedicated fuzzy chips are now available. For example, Adaptive Logic INC of San Jose, California, sells a &quot;fuzzy chip&quot;, the AL220, that can accept four analog inputs and generate four analog outputs. A block diagram of the chip is shown below:

&lt;pre&gt;
              +---------+                              +-------+
 analog --4--&amp;gt;| analog  |                              | mux / +--4--&amp;gt; analog
   in         |   mux   |                              |  SH   |        out
              +----+----+                              +-------+
                   |                                       ^
                   V                                       |
            +-------------+                             +--+--+
            | ADC / latch |                             | DAC |
            +------+------+                             +-----+
                   |                                       ^
                   |                                       |
                   8         +-----------------------------+
                   |         |                             |
                   |         V                             |
                   |   +-----------+      +-------------+  |
                   +--&amp;gt;| fuzzifier |      | defuzzifier +--+
                       +-----+-----+      +-------------+
                             |                   ^
                             |  +-------------+  |
                             |  |    rule     |  |
                             +-&amp;gt;|  processor  +--+
                                | (50 rules)  |
                                +------+------+
                                       |
                                +------+------+
                                |  parameter  |
                                |    memory   |
                                |   256 x 8   |
                                +-------------+

    ADC:  analog-to-digital converter
    DAC:  digital-to-analog converter
    SH:   sample/hold
&lt;/pre&gt;

== Antilock brakes ==
As an example, consider an [[anti-lock braking system]], directed by a microcontroller chip. The microcontroller has to make decisions based on brake [[temperature]], [[speed]], and other variables in the system.

The variable &quot;temperature&quot; in this system can be subdivided into a range of &quot;states&quot;: &quot;cold&quot;, &quot;cool&quot;, &quot;moderate&quot;, &quot;warm&quot;, &quot;hot&quot;, &quot;very hot&quot;. The transition from one state to the next is hard to define.

An arbitrary static threshold might be set to divide &quot;warm&quot; from &quot;hot&quot;. For example, at exactly 90 degrees, warm ends and hot begins. But this would result in a discontinuous change when the input value passed over that threshold. The transition wouldn't be smooth, as would be required in braking situations.

The way around this is to make the states ''fuzzy''. That is, allow them to change gradually from one state to the next. In order to do this, there must be a dynamic relationship established between different factors.

Start by defining the input temperature states using &quot;membership functions&quot;:

[[File:Fuzzy control - definition of input temperature states using membership functions.png]]

With this scheme, the input variable's state no longer jumps abruptly from one state to the next. Instead, as the temperature changes, it loses value in one membership function while gaining value in the next. In other words, its ranking in the category of cold decreases as it becomes more highly ranked in the warmer category.

At any sampled timeframe, the &quot;truth value&quot; of the brake temperature will almost always be in some degree part of two membership functions: i.e.: '0.6 nominal and 0.4 warm', or '0.7 nominal and 0.3 cool', and so on.

The above example demonstrates a simple application, using the [[abstraction]] of values from multiple values. This only represents one kind of data, however, in this case, temperature.

Adding additional sophistication to this braking system, could be done by additional factors such as [[Traction (engineering)|traction]], speed, [[inertia]], set up in dynamic functions, according to the designed fuzzy system.&lt;ref&gt;{{cite journal|last=Vichuzhanin|first=Vladimir|title=Realization of a fuzzy controller with fuzzy dynamic correction|journal=Central European Journal of Engineering|date=12 April 2012|volume=2|issue=3|pages=392–398|doi=10.2478/s13531-012-0003-7|s2cid=123008987}}&lt;/ref&gt;

==Logical interpretation of fuzzy control==
In spite of the appearance there are several difficulties to give a rigorous logical interpretation of the ''IF-THEN'' rules. As an example, interpret a rule as  ''IF (temperature is &quot;cold&quot;) THEN (heater is &quot;high&quot;)'' by the first order formula ''Cold(x)→High(y)'' and assume that r is an input such that ''Cold(r)'' is false. Then the formula ''Cold(r)→High(t)'' is true for any ''t'' and therefore any ''t'' gives a correct control given ''r''. A rigorous logical justification of fuzzy control is given in Hájek's book (see Chapter 7) where fuzzy control is represented as a theory of Hájek's basic logic.&lt;ref name = &quot;Hájek&quot; /&gt;

In Gerla 2005 &lt;ref&gt;{{cite journal|last1=Gerla|first1=Giangiacomo|title=Fuzzy logic programming and fuzzy control|journal=Studia Logica|date=2005|volume=79|issue=2|pages=231–254|doi=10.1007/s11225-005-2977-0|citeseerx=10.1.1.103.1143|s2cid=14958568}}&lt;/ref&gt; another logical approach to fuzzy control is proposed based on fuzzy logic programming: Denote by ''f'' the fuzzy function arising of an IF-THEN systems of rules. Then this system can be translated into a fuzzy program P containing a series of rules whose head is &quot;Good(x,y)&quot;. The interpretation of this predicate in the least fuzzy [[Herbrand model]] of P coincides with f. This gives further useful tools to fuzzy control.

==Fuzzy qualitative simulation==
Before an Artificial Intelligence system is able to plan the action sequence, some kind of [[Mathematical model|model]] is needed. For video games, the model is equal to the game rules. From the programming perspective, the game rules are implemented as a [[Physics engine]] which accepts an action from a player and calculates, if the action is valid. After the action was executed, the game is in follow up state. If the aim isn't only to play [[mathematical game]]s but determine the actions for real world applications, the most obvious bottleneck is, that no game rules are available. The first step is to model the domain. [[System identification]] can be realized with precise mathematical equations or with [[Fuzzy rule]]s.&lt;ref&gt;{{cite journal |title=Fuzzy qualitative simulation and diagnosis of continuous dynamic systems |author=Shen, Qiang |year=1991 |publisher=University of Edinburgh}}&lt;/ref&gt;

Using Fuzzy logic and [[Adaptive neuro fuzzy inference system|ANFIS]] systems (Adaptive network based fuzzy inference system) for creating the [[Internal_model_(motor_control)#Forward_models|forward model]] for a domain has many disadvantages.&lt;ref&gt;{{cite conference |title=Generating fuzzy models from deep knowledge: robustness and interpretability issues |author=Guglielmann, Raffaella and Ironi, Liliana |conference=European Conference on Symbolic and Quantitative Approaches to Reasoning and Uncertainty |pages=600–612 |year=2005 |publisher=Springer |doi=10.1007/11518655_51}}&lt;/ref&gt; A [[qualitative simulation]] isn't able to determine the correct follow up state, but the system will only guess what will happen if the action was taken. The Fuzzy qualitative simulation can't predict the exact numerical values, but it's using imprecise [[natural language]] to speculate about the future. It takes the current situation plus the actions from the past and generates the expected follow up state of the game.
