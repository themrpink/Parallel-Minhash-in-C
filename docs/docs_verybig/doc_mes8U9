so &lt;math display=&quot;inline&quot;&gt;\mu(X) = 1&lt;/math&gt; (by additivity of measures) and &lt;math display=&quot;inline&quot;&gt;\mu(\emptyset) = 0&lt;/math&gt; (by definition of measures).

This leads to the measure space &lt;math display=&quot;inline&quot;&gt;(X, \mathcal{P}(X), \mu)&lt;/math&gt;. It is a [[probability space]], since &lt;math display=&quot;inline&quot;&gt;\mu(X) = 1&lt;/math&gt;. The measure &lt;math display=&quot;inline&quot;&gt;\mu&lt;/math&gt; corresponds to the [[Bernoulli distribution]] with &lt;math display=&quot;inline&quot;&gt;p = \frac{1}{2}&lt;/math&gt;, which is for example used to model a fair coin flip.

== Important classes of measure spaces ==
Most important classes of measure spaces are defined by the properties of their associated measures. This includes
* [[Probability space]]s, a measure space where the measure is a [[probability measure]]&lt;ref name=&quot;Kosorok83&quot;/&gt;
* Finite measure spaces, where the measure is a [[finite measure]]&lt;ref name=&quot;eommeasurespace&quot;/&gt;
* &lt;math&gt; \sigma&lt;/math&gt;-finite measure spaces, where the measure is a [[sigma-finite measure|&lt;math&gt; \sigma &lt;/math&gt;-finite measure]]&lt;ref name=&quot;eommeasurespace&quot;/&gt;

Another class of measure spaces are the [[complete measure space]]s.&lt;ref name=&quot;Klenke33&quot; /&gt;

== References ==
&lt;references&gt;
&lt;ref name=&quot;Kosorok83&quot; &gt;{{cite book |last1=Kosorok |first1=Michael R. |year=2008  |title=Introduction to Empirical Processes and Semiparametric Inference |location=New York |publisher=Springer |page=83|isbn=978-0-387-74977-8 }}&lt;/ref&gt;
&lt;ref name=&quot;Klenke18&quot; &gt;{{cite book |last1=Klenke |first1=Achim |year=2008  |title=Probability Theory |location=Berlin |publisher=Springer |doi=10.1007/978-1-84800-048-3 |isbn=978-1-84800-047-6 |page=18}}&lt;/ref&gt;
&lt;ref name=&quot;Klenke33&quot; &gt;{{cite book |last1=Klenke |first1=Achim |year=2008  |title=Probability Theory |location=Berlin |publisher=Springer |doi=10.1007/978-1-84800-048-3 |isbn=978-1-84800-047-6 |page=33}}&lt;/ref&gt;
&lt;ref name=&quot;eommeasurespace&quot;&gt;{{SpringerEOM |title=Measure space |id=Measure_space  |author-last1=Anosov |author-first1=D.V.}}&lt;/ref&gt;
&lt;/references&gt;

[[Category:Measure theory]]</text>
      <sha1>648z4j0zgq6e1kh5yo56dwtu7o1mc8v</sha1>
    </revision>
  </page>
  <page>
    <title>Infinite loop</title>
    <ns>0</ns>
    <id>45273</id>
    <revision>
      <id>991406086</id>
      <parentid>986695067</parentid>
      <timestamp>2020-11-29T22:11:58Z</timestamp>
      <contributor>
        <ip>186.50.122.64</ip>
      </contributor>
      <comment>/* Alderson loop */</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="19706" xml:space="preserve">{{About|the programming term|the street named after this term|Infinite Loop (street)|the book by Michael S. Malone|Infinite Loop (book)}}
{{Redirect|Endless loop|EP by Eiko Shimamiya|Endless Loop}}
{{Loop constructs}}&lt;!-- NOTE: Please don't remove. Discuss navigation concept at [[Talk:Do_while_loop#Helpbox_experiment] --&gt;

In [[computer programming]], an '''infinite loop''' (or '''endless loop''')&lt;ref&gt;{{cite web
   |url=https://www.yourdictionary.com/endless-loop
   |title=Endless loop dictionary definition}}&lt;/ref&gt;&lt;ref&gt;{{cite web
   |url=https://whatis.techtarget.com/definition/infinite-loop-endless-loop
   |title=What is infinite loop (endless loop)}}&lt;/ref&gt; is a sequence of instructions that, as written, will continue endlessly, unless an external intervention occurs (&quot;pull the plug&quot;). It may be intentional.

==Overview==
This differs from:
* &quot;a type of computer program that runs the same instructions continuously until it is either stopped or interrupted.&quot;&lt;ref&gt;{{cite newspaper  
   |newspaper=[[The New York Times]]
   |url=https://archive.nytimes.com/www.nytimes.com/library/tech/99/08/biztech/articles/16digi.html
   |title=Overload of Hangers-On Creates Bumpy Ride for Internet Stocks
   |author=Denise Caruso   |date=August 16, 1999}}&lt;/ref&gt;

Consider:
&lt;syntaxhighlight lang=&quot;lua&quot;&gt;
how_many = 0
while is_there_more_data() do
    how_many = how_many + 1
end
display &quot;the number of items counted = &quot; how_many
&lt;/syntaxhighlight&gt;

''The same instructions'' were run ''continuously until it was stopped or interrupted'' . . . by the ''FALSE'' returned at some point by the function ''is_there_more_data''.

By contrast, the following loop will not end by itself:
&lt;syntaxhighlight lang=&quot;lua&quot;&gt;
birds = 1
fish = 2
while birds + fish &gt; 1 do
    birds = 3 - birds
    fish = 3 - fish
end
&lt;/syntaxhighlight&gt;

''birds'' will alternate being 1 or 2, while ''fish'' will alternate being 2 or 1. The loop will not stop unless an external intervention occurs (&quot;pull the plug&quot;).

==Details==
An ''infinite loop'' is a sequence of instructions in a [[computer program]] which loops endlessly, either due to the [[control flow#Loops|loop]] having no terminating condition,&lt;ref&gt;{{cite magazine  |magazine=Flow Journal
   |url=http://www.flowjournal.org/tag/loop-media/?print=print-search
   |title=Codes and Modes: The Character of Documentary Culture
   |quote=an infinite loop is one that lacks .. an exit condition
   |date=November 2014}}&lt;/ref&gt; having one that can never be met, or one that causes the loop to start over. In older [[operating system]]s with [[cooperative multitasking]],&lt;ref&gt;also known as non-preemptive-multitasking: {{cite magazine
   |magazine=[[PC Magazine]]
   |url=https://www.pcmag.com/encyclopedia/term/48051/non-preemptive-multitasking
   |title=Non-preemptive Multitasking  |accessdate=August 15, 2015}}&lt;/ref&gt; infinite loops normally caused the entire system to become unresponsive. With the now-prevalent preemptive multitasking model, infinite loops usually cause the program to consume all available processor time, but can usually be terminated by the user. [[Busy waiting|Busy wait]] loops are also sometimes called &quot;infinite loops&quot;. Infinite loops are one possible cause for a computer &quot;[[hang (computing)|freezing]]&quot;; others include [[thrashing (computer science)|thrashing]], [[deadlock]], and [[segmentation fault|access violation]]s.

==Intended vs unintended looping==
Looping is repeating a set of instructions until a specific condition is met. An infinite loop occurs when the condition will never be met, due to some inherent characteristic of the loop.

===Intentional looping===
There are a few situations when this is desired behavior. For example, the games on cartridge-based game consoles typically have no exit condition in their main loop, as there is no operating system for the program to exit to; the loop runs until the console is powered off.

Modern interactive computers require that the computer constantly be monitoring for user input or device activity, so at some fundamental level there is an infinite processing [[idle loop]] that must continue until the device is turned off or reset. In the [[Apollo Guidance Computer]], for example, this outer loop was contained in the Exec program,&lt;ref&gt;{{cite web
   |url=http://klabs.org/history/history_docs/mit_docs/1711.pdf
   |title=The History of Apollo On-board Guidance, Navigation, and Control
   |author=David Hoag  |date=September 1976
   |publisher=  Charles Stark Draper Laboratory}}&lt;/ref&gt; and if the computer had absolutely no other work to do it would loop run a dummy job that would simply turn off the &quot;computer activity&quot; indicator light.

Modern computers also typically do not halt the processor or motherboard circuit-driving clocks when they crash. Instead they fall back to an error condition displaying messages to the operator, and enter an infinite loop waiting for the user to either respond to a prompt to continue, or to reset the device.

====Multi-threading====
In multi-threaded programs some threads can be executing inside infinite loops without causing the entire program to be stuck in an infinite loop. If the main thread exits all threads of the process are forcefully stopped thus all execution ends and the process/program terminates. The threads inside the infinite loops can perform &quot;housekeeping&quot; tasks or they can be in a blocked state waiting for input (from socket/queue) and resume execution every time input is received.

===Unintentional looping===
Most often, the term is used for those situations when this is not the intended result; that is, when this is a [[software bug|bug]].&lt;ref&gt;{{cite web
   |url=https://nyxcrossword.com/2013/10/1013-13-new-york-times-crossword.html
   |title=New York Times Crossword Answers
   |quote=computing .. a defect .. which .. to loop
   |date=October 13, 2013}}&lt;/ref&gt; Such errors are most common among novice programmers, but can be made by experienced programmers as well, because their causes can be quite subtle.

One common cause, for example, is that the programmer intends to iterate over sequence of nodes in a [[data structure]] such as a [[linked list]] or [[tree (data structure)|tree]], executing the loop code once for each node. Improperly formed links can create a ''reference loop'' in the data structure, where one node links to another that occurs earlier in the sequence. This makes part of the data structure into a [[ring (data structure)|ring]], causing naive code to loop forever.

While most infinite loops can be found by close inspection of the code, there is no ''general'' method to determine whether a given program will ever halt or will run forever; this is the [[undecidable problem|undecidability]] of the [[halting problem]].&lt;ref&gt;{{cite web
   |url=https://www.geeksforgeeks.org/halting-problem-in-theory-of-computation
   |title=Halting Problem in Theory of Computation}}&lt;/ref&gt;

==Interruption==
As long as the system is responsive, infinite loops can often be interrupted by sending a signal to the process (such as [[SIGINT (POSIX)|SIGINT]] in Unix), or an [[interrupt]] to the processor, causing the current process to be aborted. This can be done in a [[task manager]], in a terminal with the [[Control-C]] command,&lt;ref&gt;{{cite web
   |url=https://pen-testing.sans.org/resources/papers/gcih/buffer-overflow-exploit-dameware-remote-control-software-104168
   |title=A Buffer Overflow Exploit Against the DameWare Remote Control software
   |quote=As soon as the command shell is closed with a control-c combination ...
   |date=December 19, 2003}}&lt;/ref&gt; or by using the [[kill (command)|kill]] command or [[system call]]. However, this does not always work, as the process may not be responding to signals or the processor may be in an uninterruptible state, such as in the [[Cyrix coma bug]] (caused by overlapping uninterruptible instructions in an [[instruction pipeline]]). In some cases other signals such as [[SIGKILL]] can work, as they do not require the process to be responsive, while in other cases the loop cannot be terminated short of system shutdown.

==Language support==
{{see also|Control flow}}
Infinite loops can be implemented using various [[control flow]] constructs. Most commonly, in unstructured programming this is jump back up ([[goto]]), while in structured programming this is an indefinite loop (while loop) set to never end, either by omitting the condition or explicitly setting it to true, as &lt;code&gt;while (true) ...&lt;/code&gt;.

Some languages have special constructs for infinite loops, typically by omitting the condition from an indefinite loop. Examples include Ada (&lt;code&gt;loop ... end loop&lt;/code&gt;),&lt;ref&gt;[[b:Ada Programming/Control#Endless Loop|Ada Programming: Control: Endless Loop]]&lt;/ref&gt; Fortran (&lt;code&gt;DO ... END DO&lt;/code&gt;), Go (&lt;code&gt;for { ... }&lt;/code&gt;), and Ruby (&lt;code&gt;loop do ... end&lt;/code&gt;).

==Examples of intentional infinite loops==
A simple example (in [[C (programming language)|C]]):

&lt;syntaxhighlight lang=&quot;c&quot; line=&quot;1&quot;&gt;
#include &lt;stdio.h&gt;

int main()
{
  for (;;) // or equivalently, while (1)
  {
    printf(&quot;Infinite Loop\n&quot;);
  }
  return 0;
}
&lt;/syntaxhighlight&gt;
The form &lt;code&gt;for (;;)&lt;/code&gt; for an infinite loop is traditional, appearing in the standard reference ''[[The C Programming Language]]'', and is often punningly pronounced &quot;forever&quot;.&lt;ref&gt;{{Cite web |url=https://stackoverflow.com/questions/20186809/endless-loop-in-c-c |title=Endless loop in C/C++ |url-status=live |archive-url=https://web.archive.org/web/20160803202212/http://stackoverflow.com/questions/20186809/endless-loop-in-c-c |archive-date=2016-08-03}}&lt;/ref&gt;

This is a loop that will print &quot;Infinite Loop&quot; without halting.

A similar example in 1980s-era [[BASIC programming language|BASIC]]:
&lt;syntaxhighlight lang=&quot;gwbasic&quot;&gt;
10 PRINT &quot;INFINITE LOOP&quot;
20 GOTO 10
&lt;/syntaxhighlight&gt;

A similar example in [[DOS]] batch files:
&lt;syntaxhighlight lang=&quot;bat&quot;&gt;
:A
echo Infinite Loop
goto :A
&lt;/syntaxhighlight&gt;
Here the loop is quite obvious, as the last line unconditionally sends execution back to the first.

An example in [[Java (programming language)|Java]]
&lt;syntaxhighlight lang=&quot;java&quot;&gt;
while (true) 
    System.out.println(&quot;Infinite Loop&quot;);
&lt;/syntaxhighlight&gt;

An example in [[Bourne Again Shell]]
&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
for ((;;)); do
	echo &quot;Infinite Loop&quot;
done
&lt;/syntaxhighlight&gt;

An example in [[Rust (programming language)|Rust]]
&lt;syntaxhighlight lang=&quot;rust&quot;&gt;
loop {
    println!(&quot;Infinite loop&quot;);
}
&lt;/syntaxhighlight&gt;

==Examples of unintentional infinite loops==

===Mathematical errors===
Here is one example of an infinite loop in [[Visual Basic]]:
&lt;syntaxhighlight lang=vb&gt;
dim x as integer
do while x &lt; 5
  x = 1
  x = x + 1
loop

&lt;/syntaxhighlight&gt;
This creates a situation where &lt;code&gt;x&lt;/code&gt; will never be greater than 5, since at the start of the loop code &lt;code&gt;x&lt;/code&gt; is given the value of 1, thus, the loop will always end in 2 and the loop will never break. This could be fixed by moving the &lt;code&gt;x = 1&lt;/code&gt; instruction outside the loop. Essentially what this infinite loop does is to instruct a computer to keep on adding 1 to 1 until 5 is reached. Since 1+1 always equals 2, this will never happen.

In some languages, programmer confusion about the mathematical symbols may lead to an unintentional infinite loop. For example, here is a snippet in [[C (programming language)|C]]:
&lt;syntaxhighlight lang=c&gt;
#include &lt;stdio.h&gt;

int main(void)
{
   int a = 0;
   while (a &lt; 10) {
      printf(&quot;%d\n&quot;, a);
      if (a = 5)
         printf(&quot;a equals 5!\n&quot;);
      a++;
   }
   return 0;
}
&lt;/syntaxhighlight&gt;

The expected output is the numbers 0 through 9, with an interjected &quot;a equals 5!&quot; between 5 and 6. However, in the line &quot;&lt;code&gt;if (a = 5)&lt;/code&gt;&quot; above, the programmer has confused the = (assignment) operator with the == (equality test) operator. Instead, this will assign the value of 5 to &lt;code&gt;a&lt;/code&gt; at this point in the program. Thus, &lt;code&gt;a&lt;/code&gt; will never be able to advance to 10, and this loop cannot terminate.

===Rounding errors===

{| style=&quot;float:right; border: 1px solid grey;&quot;
|-
| ''C output on an [[AMD Turion]] processor:''
|- 
|x = 0.10000000149011611938      
|- 
|x = 0.20000000298023223877      
|- 
|x = 0.30000001192092895508      
|- 
|x = 0.40000000596046447754      
|- 
|x = 0.50000000000000000000      
|- 
|x = 0.60000002384185791016      
|- 
|x = 0.70000004768371582031      
|- 
|x = 0.80000007152557373047      
|- 
|x = 0.90000009536743164062      
|- 
|x = 1.00000011920928955078      
|- 
|x = 1.10000014305114746094      
|- 
|x = 1.20000016689300537109      
|- 
| ...
|}

Unexpected behavior in evaluating the terminating condition can also cause this problem. Here is an example in [[C (programming language)|C]]:

&lt;syntaxhighlight lang=&quot;c&quot;&gt;
float x = 0.1;
while (x != 1.1) {
  printf(&quot;x = %22.20f\n&quot;, x);
  x += 0.1;
}
&lt;/syntaxhighlight&gt;

On some systems, this loop will execute ten times as expected, but on other systems it will never terminate. The problem is that the loop terminating condition &lt;tt&gt;(x != 1.1)&lt;/tt&gt; tests for exact equality of two [[floating point]] values, and the way floating point values are represented in many computers will make this test fail, because they cannot represent the value 0.1 exactly, thus introducing rounding errors on each increment (cf. box).

The same can happen in [[Python (programming language)|Python]]:
&lt;syntaxhighlight lang=&quot;python&quot;&gt;
x = 0.1
while x != 1:
    print(x)
    x += 0.1
&lt;/syntaxhighlight&gt;

Because of the likelihood of tests for equality or not-equality failing unexpectedly, it is safer to use greater-than or less-than tests when dealing with floating-point values. For example, instead of testing whether &lt;code&gt;x&lt;/code&gt; equals 1.1, one might test whether &lt;tt&gt;(x &lt;= 1.0)&lt;/tt&gt;, or &lt;tt&gt;(x &lt; 1.1)&lt;/tt&gt;, either of which would be certain to exit after a finite number of iterations. Another way to fix this particular example would be to use an [[integer (computer science)|integer]] as a [[control flow|loop index]], counting the number of iterations that have been performed.

A similar problem occurs frequently in [[numerical analysis]]: in order to compute a certain result, an iteration is intended to be carried out until the error is smaller than a chosen tolerance. However, because of rounding errors during the iteration, the specified tolerance can never be reached, resulting in an infinite loop.

==Multi-party loops==
[[File:Google Home vs. Amazon Echo.webm|thumb|Video of infinite loop by Google Home vs. Amazon Echo]]
An infinite loop may be caused by several entities interacting. Consider a server that always replies with an error message if it does not understand the request. Even if there is no possibility for an infinite loop within the server itself, a system comprising two of them (''A'' and ''B'') may loop endlessly: if ''A'' receives a message of unknown type from ''B'', then ''A'' replies with an error message to ''B''; if ''B'' does not understand the error message, it replies to ''A'' with its own error message; if ''A'' does not understand the error message from ''B'', it sends yet another error message, and so on.

One common example of such situation is an [[email loop]]. An example of an email loop is if someone receives mail from a no reply inbox, but their auto-response is on. They will reply to the no reply inbox, triggering the &quot;this is a no reply inbox&quot; response. This will be sent to the user, who then sends an auto reply to the no-reply inbox, and so on and so forth.

==Pseudo-infinite loops==
A pseudo-infinite loop is a loop that appears infinite but is really just a very long loop.
