==External links==
* [http://simul.iro.umontreal.ca/testu01/tu01.html TestU01]: A free, state-of-the-art ([[GNU General Public License|GPL]]) [[C++]] Random Number Test Suite.
* [http://www.phy.duke.edu/~rgb/General/rand_rate.php DieHarder]: A free ([[GNU General Public License|GPL]]) [[C (programming language)|C]] Random Number Test Suite.
* &quot;[http://www.embedded.com/design/configurable-systems/4024972/Generating-random-numbers Generating random numbers]&quot; (in [[embedded systems]]) by Eric Uner (2004)
* &quot;[http://eprint.iacr.org/2006/086 Analysis of the Linux Random Number Generator]&quot; by Zvi Gutterman, [[Benny Pinkas]], and Tzachy Reinman (2006)
* &quot;[http://research.microsoft.com/apps/pubs/default.aspx?id=168806 Better pseudorandom generators]&quot; by Parikshit Gopalan, Raghu Meka, [[Omer Reingold]], [[Luca Trevisan]], and [[Salil Vadhan]] ([[Microsoft Research]], 2012)
* {{Youtube|LDPMpc-ENqY|rand() Considered Harmful}} by Stephan Lavavej (Microsoft, 2013) &lt;!-- he maintains Visual Studio C++ STL (library) as stated here https://nuwen.net/stl.html --&gt;
* [http://wsphynx.com/simpleApp/random.html Wsphynx] a simple online random number generator.Random number are generated by Javascript pseudorandom number generators (PRNGs) algorithms

{{DEFAULTSORT:Pseudorandom Number Generator}}
[[Category:Pseudorandom number generators|*]]</text>
      <sha1>bxbm3fytfm1gyc0vcjex5cub3fxzzqs</sha1>
    </revision>
  </page>
  <page>
    <title>Linear congruential generator</title>
    <ns>0</ns>
    <id>45527</id>
    <revision>
      <id>981859053</id>
      <parentid>979633695</parentid>
      <timestamp>2020-10-04T20:44:50Z</timestamp>
      <contributor>
        <ip>86.16.88.32</ip>
      </contributor>
      <comment>/* Parameters in common use */ unnecessary 'C' hex prefix</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="35385" xml:space="preserve">[[File:Linear_congruential_generator_visualisation.svg|thumb|480px|Two modulo-9 LCGs show how different parameters lead to different cycle lengths. Each row shows the state evolving until it repeats. The top row shows a generator with ''m''&amp;nbsp;=&amp;nbsp;9, ''a''&amp;nbsp;=&amp;nbsp;2, ''c''&amp;nbsp;=&amp;nbsp;0, and a seed of 1, which produces a cycle of length 6. The second row is the same generator with a seed of 3, which produces a cycle of length 2. Using ''a''&amp;nbsp;=&amp;nbsp;4 and ''c''&amp;nbsp;=&amp;nbsp;1 (bottom row) gives a cycle length of 9 with any seed in [0,&amp;nbsp;8].]]
A '''linear congruential generator''' ('''LCG''') is an [[algorithm]] that yields a sequence of pseudo-randomized numbers calculated with a discontinuous [[piecewise linear function|piecewise linear equation]]. The method represents one of the oldest and best-known [[pseudorandom number generator]] algorithms.&lt;ref&gt;&quot;[http://demonstrations.wolfram.com/LinearCongruentialGenerators/ Linear Congruential Generators]&quot; by Joe Bolte, [[Wolfram Demonstrations Project]].&lt;/ref&gt; The theory behind them is relatively easy to understand, and they are easily implemented and fast, especially on computer hardware which can provide [[modular arithmetic]] by storage-bit truncation.

The generator is defined by [[recurrence relation]]:

:&lt;math&gt;X_{n+1} = \left( a X_n + c \right)\bmod m&lt;/math&gt;

where &lt;math&gt;X&lt;/math&gt; is the [[sequence]] of pseudorandom values, and

: &lt;math&gt; m,\, 0&lt;m &lt;/math&gt; — the &quot;[[modulo operation|modulus]]&quot;
: &lt;math&gt; a,\,0 &lt; a &lt; m&lt;/math&gt; — the &quot;multiplier&quot;
: &lt;math&gt; c,\,0 \le c &lt; m&lt;/math&gt; — the &quot;increment&quot;
: &lt;math&gt; X_0,\,0 \le X_0 &lt; m&lt;/math&gt; — the &quot;seed&quot; or &quot;start value&quot;

are [[integer]] constants that specify the generator. If ''c''&amp;nbsp;=&amp;nbsp;0, the generator is often called a '''multiplicative congruential generator''' (MCG), or [[Lehmer RNG]]. If ''c''&amp;nbsp;≠&amp;nbsp;0, the method is called a '''mixed congruential generator'''.{{r|KnuthV2|p=4-}}

When ''c''&amp;nbsp;≠&amp;nbsp;0, a mathematician would call the recurrence an [[affine transformation]], not a [[Linear transformation|linear]] one, but the misnomer is well-established in computer science.&lt;ref name=Steele20&gt;{{cite arxiv
 |title=Computationally easy, spectrally good multipliers for congruential pseudorandom number generators
 |first1=Guy |last1=Steele |authorlink1=Guy Steele |first2=Sebastiano |last2=Vigna |authorlink2=Sebastiano Vigna
 |eprint=2001.05304 |class=cs.DS |date=15 January 2020
 |quote=At this point it is unlikely that the now-traditional names will be corrected.
}} [[Mathematics of Computation]] (to appear).  Associated data at https://github.com/vigna/CPRNG.&lt;/ref&gt;{{Rp|1}}

== Period length ==
A benefit of LCGs is that with appropriate choice of parameters, the period is known and long. Although not the only criterion, too short a period is a fatal flaw in a pseudorandom number generator.&lt;ref name=History&gt;{{cite conference
 |title=History of Uniform Random Number Generation
 |first=Pierre |last=L'Ecuyer
 |date=13 July 2017&lt;!--Conference is in December 2017--&gt;
 |conference=Proceedings of the 2017 Winter Simulation Conference (to appear)
 |editor1-first=W. K. V. |editor1-last=Chan |editor2-first=A. |editor2-last=D’Ambrogio |editor3-first=G. |editor3-last=Zacharewicz
 |editor4-first=N. |editor4-last=Mustafee |editor5-first=G. |editor5-last=Wainer |editor6-first=E. |editor6-last=Page
 |url=https://www.iro.umontreal.ca/~lecuyer/myftp/papers/wsc17rng-history.pdf
 |location=Las Vegas, United States
 |id=[https://hal.inria.fr/hal-01561551 hal-01561551]
}}&lt;/ref&gt;

While LCGs are capable of producing [[pseudorandom numbers]] which can pass formal [[tests for randomness]], the quality of the output is extremely sensitive to the choice of the parameters ''m'' and ''a''.{{r|Marsaglia68|KnuthV2|Park88|Hörmann92|LEcuyer99|Steele20}}  For example, ''a''&amp;nbsp;=&amp;nbsp;1 and ''c''&amp;nbsp;=&amp;nbsp;1 produces a simple modulo-''m'' counter, which has a long period, but is obviously non-random.

Historically, poor choices for ''a'' have led to ineffective implementations of LCGs. A particularly illustrative example of this is [[RANDU]], which was widely used in the early 1970s and led to many results which are currently being questioned because of the use of this poor LCG.&lt;ref name=&quot;Press&quot;&gt;{{cite book |last=Press |
first=William H. |year=1992 |title=Numerical Recipes in Fortran 77: The Art of Scientific Computing |edition=2nd |isbn=978-0-521-43064-7 |display-authors=etal |title-link=Numerical Recipes }}&lt;/ref&gt;

There are three common families of parameter choice:

=== ''m'' prime, ''c'' = 0 ===
{{main|Lehmer random number generator}}
This is the original Lehmer RNG construction. The period is ''m''−1 if the multiplier ''a'' is chosen to be a [[Primitive element (finite field)|primitive element]] of the integers modulo ''m''. The initial state must be chosen between 1 and ''m''−1.

One disadvantage of a prime modulus is that the modular reduction requires a double-width product and an explicit reduction step. Often a prime just less than a power of 2 is used (the [[Mersenne prime]]s 2&lt;sup&gt;31&lt;/sup&gt;−1 and 2&lt;sup&gt;61&lt;/sup&gt;−1 are popular), so that the reduction modulo ''m''&amp;nbsp;=&amp;nbsp;2&lt;sup&gt;''e''&lt;/sup&gt;&amp;nbsp;−&amp;nbsp;''d'' can be computed as (''ax''&amp;nbsp;mod&amp;nbsp;2&lt;sup&gt;''e''&lt;/sup&gt;)&amp;nbsp;+&amp;nbsp;''d''&amp;nbsp;{{floor|''ax''/2&lt;sup&gt;''e''&lt;/sup&gt;}}. This must be followed by a conditional subtraction of ''m'' if the result is too large, but the number of subtractions is limited to ''ad''/''m'', which can be easily limited to one if ''d'' is small.

If a double-width product is unavailable, and the multiplier is chosen carefully, '''Schrage's method'''&lt;ref&gt;{{cite web
 |title=Computer Systems Performance Analysis Chapter 26: Random-Number Generation
 |first=Raj |last=Jain |date=9 July 2010
 |pages=19–20
 |url=http://www.cse.wustl.edu/~jain/iucee/ftp/k_26rng.pdf#page=19
 |accessdate=2017-10-31
}}&lt;/ref&gt; may be used. To do this, factor ''m''&amp;nbsp;=&amp;nbsp;''qa''+''r'', i.e. {{nobr|1=''q'' = {{floor|''m''/''a''}}}} and {{nobr|1=''r'' = ''m'' mod ''a''}}. Then compute ''ax''&amp;nbsp;mod&amp;nbsp;''m'' = {{nobr|''a''(''x'' mod ''q'') − ''r''&amp;thinsp;{{floor|''x''/''q''}}}}. Since ''x''&amp;nbsp;mod&amp;nbsp;''q'' &lt; ''q'' ≤ ''m''/''a'', the first term is strictly less than ''am''/''a''&amp;nbsp;=&amp;nbsp;''m''. If ''a'' is chosen so that ''r''&amp;nbsp;≤&amp;nbsp;''q'' (and thus ''r''/''q''&amp;nbsp;≤&amp;nbsp;1), then the second term is also less than ''m'': ''r''&amp;thinsp;{{floor|''x''/''q''}} ≤ ''rx''/''q'' = ''x''(''r''/''q'') ≤ ''x'' &lt; ''m''. Thus, both products can be computed with a single-width product, and the difference between them lies in the range [1−''m'',&amp;nbsp;''m''−1], so can be reduced to [0,&amp;nbsp;''m''−1] with a single conditional add.&lt;ref&gt;{{cite web
 |title=Schrage's Method
 |url=http://home.earthlink.net/~pfenerty/pi/schrages_method.html
 |first=Paul |last=Fenerty |date=11 September 2006
 |accessdate=2017-10-31
}}&lt;/ref&gt;

A second disadvantage is that it is awkward to convert the value 1&amp;nbsp;≤&amp;nbsp;''x''&amp;nbsp;&lt;&amp;nbsp;''m'' to uniform random bits. If a prime just less than a power of 2 is used, sometimes the missing values are simply ignored.

=== ''m'' a power of 2, ''c'' = 0 ===
Choosing ''m'' to be a [[Power of two|power of 2]], most often ''m'' = 2&lt;sup&gt;32&lt;/sup&gt; or ''m'' = 2&lt;sup&gt;64&lt;/sup&gt;, produces a particularly efficient LCG, because this allows the modulus operation to be computed by simply truncating the binary representation. In fact, the most significant bits are usually not computed at all. There are, however, disadvantages.

This form has maximal period ''m''/4, achieved if ''a''&amp;nbsp;≡&amp;nbsp;3 or ''a''&amp;nbsp;≡&amp;nbsp;5 (mod 8). The initial state ''X''&lt;sub&gt;0&lt;/sub&gt; must be odd, and the low three bits of ''X'' alternate between two states and are not useful. It can be shown that this form is equivalent to a generator with a modulus a quarter the size and ''c'' ≠ 0.{{r|KnuthV2}}

A more serious issue with the use of a power-of-two modulus is that the low bits have a shorter period than the high bits. The lowest-order bit of ''X'' never changes (''X'' is always odd), and the next two bits alternate between two states. (If ''a''&amp;nbsp;≡&amp;nbsp;5 (mod 8), then bit 1 never changes and bit 2 alternates. If ''a''&amp;nbsp;≡&amp;nbsp;3 (mod 8), then bit 2 never changes and bit 1 alternates.) Bit 3 repeats with a period of 4, bit 4 has a period of 8, and so on. Only the most significant bit of ''X'' achieves the full period.

=== ''c'' ≠ 0 ===
When ''c'' ≠ 0, correctly chosen parameters allow a period equal to ''m'', for all seed values. This will occur [[if and only if]]:{{r|KnuthV2|p=17—19}}
# &lt;math&gt;m&lt;/math&gt; and &lt;math&gt;c&lt;/math&gt; are [[coprime integers|relatively prime]],
# &lt;math&gt;a - 1&lt;/math&gt; is divisible by all [[prime factor]]s of &lt;math&gt;m&lt;/math&gt;,
# &lt;math&gt;a - 1&lt;/math&gt; is divisible by 4 if &lt;math&gt;m&lt;/math&gt; is divisible by 4.

These three requirements are referred to as the Hull–Dobell Theorem.&lt;ref&gt;{{Cite journal
 |last=Hull |first=T. E. |last2=Dobell |first2=A. R.
 |date=July 1962
 |title=Random Number Generators
 |url=http://chagall.med.cornell.edu/BioinfoCourse/PDFs/Lecture4/random_number_generator.pdf
 |journal=SIAM Review |volume=4 |issue=3 |pages=230–254 
 |accessdate= 2016-06-26 |doi=10.1137/1004061
}}&lt;/ref&gt;&lt;ref name=&quot;HullDobell&quot;&gt;{{cite book
 |title=System Modeling and Simulation
 |publisher=John Wiley &amp; Sons, Ltd.
 |author=Severance, Frank |year=2001 |page=86
 |isbn=978-0-471-49694-6
}}&lt;/ref&gt;

This form may be used with any ''m'', but only works well for ''m'' with many repeated prime factors, such as a power of 2; using a computer's [[word size]] is the most common choice.  If ''m'' were a [[square-free integer]], this would only allow ''a''&amp;nbsp;≡&amp;nbsp;1 (mod&amp;nbsp;''m''), which makes a very poor PRNG; a selection of possible full-period multipliers is only available when ''m'' has repeated prime factors.

Although the Hull–Dobell theorem provides maximum period, it is not sufficient to guarantee a ''good'' generator.  For example, it is desirable for ''a''&amp;nbsp;−&amp;nbsp;1 to not be any more divisible by prime factors of ''m'' than necessary.  Thus, if ''m'' is a power of 2, then ''a''&amp;nbsp;−&amp;nbsp;1 should be divisible by 4 but not divisible by 8, i.e.&amp;nbsp;''a''&amp;nbsp;≡&amp;nbsp;5&amp;nbsp;(mod&amp;nbsp;8).{{r|KnuthV2|p=§3.2.1.3}}

Indeed, most multipliers produce a sequence which fails one test for non-randomness or another, and finding a multiplier which is satisfactory to all applicable criteria{{r|KnuthV2|p=§3.3.3}} is quite challenging.  The [[spectral test]] is one of the most important tests.&lt;ref name=Austin2008&gt;{{cite web |first=David |last=Austin |title=Random Numbers: Nothing Left to Chance |date=March 2008 |publisher=American Mathematical Society |url=https://www.ams.org/publicoutreach/feature-column/fcarc-random}}&lt;/ref&gt;

Note that a power-of-2 modulus shares the problem as described above for ''c''&amp;nbsp;=&amp;nbsp;0: the low ''k'' bits form a generator with modulus 2&lt;sup&gt;''k''&lt;/sup&gt; and thus repeat with a period of 2&lt;sup&gt;''k''&lt;/sup&gt;; only the most significant bit achieves the full period.  If a pseudorandom number less than ''r'' is desired, {{floor|''rX''/''m''}} is a much higher-quality result than ''X'' mod ''r''.  Unfortunately, most programming languages make the latter much easier to write (&lt;code&gt;X % r&lt;/code&gt;), so it is the more commonly used form.

The generator is ''not'' sensitive to the choice of ''c'', as long as it is relatively prime to the modulus (e.g. if ''m'' is a power of 2, then ''c'' must be odd), so the value ''c''=1 is commonly chosen.

The series produced by other choices of ''c'' can be written as a simple function of the series when ''c''=1.{{r|KnuthV2|p=11}}  Specifically, if ''Y'' is the prototypical series defined by ''Y''&lt;sub&gt;0&lt;/sub&gt; =&amp;nbsp;0 and ''Y''&lt;sub&gt;''n''+1&lt;/sub&gt; =&amp;nbsp;''aY&lt;sub&gt;n&lt;/sub&gt;''+1 mod&amp;nbsp;m, then a general series ''X''&lt;sub&gt;''n''+1&lt;/sub&gt; =&amp;nbsp;''aX&lt;sub&gt;n&lt;/sub&gt;''+''c'' mod&amp;nbsp;''m'' can be written as an affine function of ''Y'':
:&lt;math&gt;X_n = (X_0(a-1)+c)Y_n + X_0 = (X_1 - X_0)Y_n + X_0 \pmod m.&lt;/math&gt;
More generally, any two series ''X'' and ''Z'' with the same multiplier and modulus are related by
:&lt;math&gt;{ X_n - X_0 \over X_1 - X_0 } = Y_n = {a^n - 1 \over a - 1} = { Z_n - Z_0 \over Z_1 - Z_0 } \pmod m.&lt;/math&gt;

== Parameters in common use ==
The following table lists the parameters of LCGs in common use, including built-in ''rand()'' functions in [[Runtime library|runtime libraries]] of various [[compiler]]s.  This table is to show popularity, not examples to emulate; ''many of these parameters are poor.''  Tables of good parameters are available.{{r|LEcuyer99|Steele20}}

{|class=&quot;wikitable&quot;
! Source || modulus&lt;br/&gt;''m'' || multiplier&lt;br/&gt;''a''{{ns}} || increment&lt;br/&gt;''c'' || output bits of seed in ''rand()'' or ''Random(L)''
|-
| ''[[Numerical Recipes]]'' || 2³² || 1664525 || 1013904223 || 
|-
| [[Borland]] C/C++ || 2³² || 22695477 || 1 || bits 30..16 in ''rand()'', 30..0 in ''lrand()''
|-
| [[glibc]] (used by [[GNU Compiler Collection|GCC]])&lt;ref&gt;[https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/random_r.c;hb=glibc-2.26#l362 Implementation in glibc-2.26 release.] See the code after the test for &quot;TYPE_0&quot;; the GNU C library's ''rand()'' in [[stdlib.h]] uses a simple (single state) linear congruential generator only in case that the state is declared as 8 bytes. If the state is larger (an array), the generator becomes an additive feedback generator ([https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/random_r.c;hb=glibc-2.26#l187 initialized using ''minstd_rand0'']) and the period increases. See the [http://www.mscs.dal.ca/~selinger/random/ simplified code] that reproduces the random sequence from this library.&lt;/ref&gt;
| 2³¹ || 1103515245 || 12345 || bits 30..0
|-
| [[ANSI C]]: [[Watcom C compiler|Watcom]], [[Digital Mars]], [[CodeWarrior]], [[IBM VisualAge]] C/C++ &lt;ref&gt;{{cite book|title=A collection of selected pseudorandom number generators with linear structures |author=K. Entacher |date=21 August 1997 |url=http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3686&amp;rep=rep1&amp;type=pdf |accessdate=16 June 2012 |citeseerx=10.1.1.53.3686}}&lt;/ref&gt;&lt;br/&gt;[[C90 (C version)|C90]], [[C99]], [[C11 (C standard revision)|C11]]: Suggestion in the ISO/IEC 9899,&lt;ref&gt;{{cite web|title=Last public Committee Draft from April 12, 2011|page=346f|url=http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf|accessdate=21 Dec 2014}}&lt;/ref&gt; [[C18 (C standard revision)|C18]] || 2³¹ || 1103515245 || 12345 || bits 30..16
|-
| [[Borland Delphi]], [[Virtual Pascal]] || 2³² || 134775813 || 1 || bits 63..32 of ''(seed × L)''
|-
| [[Turbo Pascal]] || 2³² || 134775813 (8088405₁₆) || 1 ||
|-
| [[Visual C++|Microsoft Visual/Quick C/C++]] || 2³² || 214013 (343FD₁₆) || 2531011 (269EC3₁₆) || bits 30..16
|-
| [[Visual Basic|Microsoft Visual Basic]] (6 and earlier)&lt;ref&gt;{{cite web|title=How Visual Basic Generates Pseudo-Random Numbers for the RND Function|url=http://support.microsoft.com/kb/231847|work=Microsoft Support|publisher=Microsoft|accessdate=17 June 2011}}&lt;/ref&gt; || 2²⁴ || 1140671485 (43FD43FD₁₆) || 12820163 (C39EC3₁₆) ||
|-
| RtlUniform from [[Native API]]&lt;ref&gt;In spite of documentation on [http://msdn.microsoft.com/en-us/library/bb432429(VS.85).aspx MSDN], RtlUniform uses LCG, and not Lehmer's algorithm, implementations before [[Windows Vista]] are flawed, because the result of multiplication is cut to 32 bits, before modulo is applied&lt;/ref&gt; || 2³¹ − 1
|| 2147483629 (7FFFFFED₁₆) || 2147483587 (7FFFFFC3₁₆) ||
|-
| [[CarbonLib|Apple CarbonLib]], [[C++11]]'s &lt;code&gt;minstd_rand0&lt;/code&gt;&lt;ref name=&quot;cpp11&quot;&gt;{{ cite web | authorlink = ISO | title = ISO/IEC 14882:2011 | publisher = ISO | date = 2 September 2011 | url = http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=50372 | accessdate =3 September 2011 }}&lt;/ref&gt; || 2³¹ − 1 || 16807 || 0 || see [[MINSTD]]
|-
| [[C++11]]'s &lt;code&gt;minstd_rand&lt;/code&gt;&lt;ref name=&quot;cpp11&quot; /&gt; || 2³¹ − 1 || 48271 || 0 || see [[MINSTD]]
|-
| [[MMIX]] by [[Donald Knuth]] || 2⁶⁴ || 6364136223846793005 || 1442695040888963407 ||
|-
| [[Newlib]], [[Musl]] || 2⁶⁴ || 6364136223846793005 || 1 || bits 63..32
|-
| [[OpenVMS|VMS]]'s '''MTH$RANDOM''',&lt;ref&gt;[https://www.gnu.org/software/gsl/manual/html_node/Other-random-number-generators.html GNU Scientific Library: Other random number generators]&lt;/ref&gt; old versions of [[glibc]] || 2³² || 69069 (10DCD₁₆) || 1 ||
|-
| [[Java (programming language)|Java]]'s java.util{{Not a typo|.}}Random, [[POSIX]] [ln]rand48, [[glibc]] [ln]rand48[_r]|| 2⁴⁸ || 25214903917 (5DEECE66D₁₆) || 11 || bits 47..16
|-
|
&lt;code&gt;random0&lt;/code&gt;&lt;ref&gt;
Stephen J. Chapman.
&quot;Example 6.4 – Random Number Generator&quot;.
[https://books.google.com/books?id=e80HBgAAQBAJ &quot;MATLAB Programming for Engineers&quot;].
2015.
pp. 253–256.
&lt;/ref&gt;&lt;ref&gt;
Stephen J. Chapman.
&quot;Example 6.4 – Random Number Generator&quot;.
[https://books.google.com/books?id=of8KAAAAQBAJ &quot;MATLAB Programming with Applications for Engineers&quot;].
2012.
pp. 292–295.
&lt;/ref&gt;&lt;ref&gt;
S. J. Chapman.
[http://www.udel.edu/CIS/106/pconrad/MPE3/code/chap5/random0.m random0].
2004.
&lt;/ref&gt;&lt;ref&gt;
Stephen J. Chapman.
[https://books.google.com/books?id=QoVGAAAAYAAJ &quot;Introduction to Fortran 90/95&quot;].
1998.
pp. 322–324.
&lt;/ref&gt;&lt;ref&gt;
Wu-ting Tsai.
[http://homepage.ntu.edu.tw/~wttsai/fortran/ppt/11.Module.pdf &quot;'Module': A Major Feature of the Modern Fortran&quot;].
pp. 6–7.
&lt;/ref&gt;
|| 134456 = 2³7⁵ || 8121 || 28411 || &lt;math&gt;\frac{ X_n }{ 134456 }&lt;/math&gt;
|-
| [[POSIX]]&lt;ref&gt;[http://pubs.opengroup.org/onlinepubs/9699919799/ The Open Group Base Specifications Issue 7]
IEEE Std 1003.1, 2013 Edition&lt;/ref&gt; [jm]rand48, [[glibc]] [mj]rand48[_r]|| 2⁴⁸ || 25214903917 (5DEECE66D₁₆) || 11 || bits 47..15
|-
| [[POSIX]] [de]rand48, [[glibc]] [de]rand48[_r]|| 2⁴⁸ || 25214903917 (5DEECE66D₁₆) || 11 || bits 47..0
|-
| [[cc65]]&lt;ref&gt;{{cite web|first=Sidney|last=Cadot|url=https://github.com/cc65/cc65/blob/master/libsrc/common/rand.s|title=rand.s|work=cc65|accessdate=8 July 2016}}&lt;/ref&gt; || 2²³ || 65793 (10101₁₆) || 4282663 (415927₁₆) || bits 22..8
|-
| [[cc65]] || 2³² || 16843009 (1010101₁₆) || 826366247 (31415927₁₆) || bits 31..16
|- style=&quot;border-top:2px solid;&quot;
| ''Formerly common:'' {{midsize|[[RANDU]]}} &lt;ref name=Press/&gt; || 2³¹ || 65539 || 0 ||
|}

As shown above, LCGs do not always use all of the bits in the values they produce. For example, the [[Java (programming language)|Java]] implementation operates with 48-bit values at each iteration but returns only their 32 most significant bits. This is because the higher-order bits have longer periods than the lower-order bits (see below). LCGs that use this truncation technique produce statistically better values than those that do not. This is especially noticeable in scripts that use the mod operation to reduce range; modifying the random number mod 2 will lead to alternating 0 and 1 without truncation.

== Advantages and disadvantages ==
{{Unreferenced section|date=June 2017}}

LCGs are fast and require minimal memory (one modulo-''m'' number, often 32 or 64 bits) to retain state. This makes them valuable for simulating multiple independent streams.  LCGs are not intended, and must not be used, for cryptographic applications; use a [[cryptographically secure pseudorandom number generator]] for such applications.

[[Image:Lcg 3d.gif|thumb|200px|[[Hyperplane]]s of a linear congruential generator in three dimensions. This structure is what the [[spectral test]] measures.]]

Although LCGs have a few specific weaknesses, many of their flaws come from having too small a state. The fact that people have been lulled for so many years into using them with such small moduli can be seen as a testament to strength of the technique. A LCG with large enough state can pass even stringent statistical tests; a modulo-2 LCG which returns the high 32 bits passes [[TestU01]]'s SmallCrush suite,{{citation needed|date=November 2017|reason=O'Neill stated this result somewhere, but I'm having a hard time finding it.}} and a 96-bit LCG passes the most stringent BigCrush suite.&lt;ref&gt;{{cite techreport
 |title=PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation
 |first=Melissa E. |last=O'Neill
 |publisher=[[Harvey Mudd College]]
 |id=HMC-CS-2014-0905
 |date=5 September 2014
 |pages=6–7
 |url=http://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf#page=9
}}&lt;/ref&gt;

For a specific example, an ideal random number generator with 32 bits of output is expected (by the [[Birthday theorem]]) to begin duplicating earlier outputs after {{sqrt|''m''}} &amp;asymp;&amp;nbsp;2&lt;sup&gt;16&lt;/sup&gt; results. ''Any'' PRNG whose output is its full, untruncated state will not produce duplicates until its full period elapses, an easily detectable statistical flaw. For related reasons, any PRNG should have a period longer than the square of the number of outputs required. Given modern computer speeds, this means a period of 2&lt;sup&gt;64&lt;/sup&gt; for all but the least demanding applications, and longer for demanding simulations.

One flaw specific to LCGs is that, if used to choose points in an n-dimensional space, the points will lie on, at most, {{radic|''n''!⋅''m''|''n''}} [[hyperplanes]] ([[Marsaglia's Theorem]], developed by [[George Marsaglia]]).&lt;ref name=Marsaglia68&gt;{{cite journal
 |title=Random Numbers Fall Mainly in the Planes
 |first=George |last=Marsaglia |authorlink=George Marsaglia
 |journal=[[PNAS]] |date=September 1968 |volume=61 |issue=1 |pages=25–28
 |doi=10.1073/pnas.61.1.25 |doi-access=free |bibcode=1968PNAS...61...25M |pmc=285899
 |url=https://www.pnas.org/content/61/1/25.full.pdf |pmid=16591687
 }}&lt;/ref&gt; This is due to serial correlation between successive values of the sequence ''X&lt;sub&gt;n&lt;/sub&gt;''. Carelessly chosen multipliers will usually have far fewer, widely spaced planes, which can lead to problems. The [[spectral test]], which is a simple test of an LCG's quality, measures this spacing and allows a good multiplier to be chosen.

The plane spacing depends both on the modulus and the multiplier. A large enough modulus can reduce this distance below the resolution of double precision numbers. The choice of the multiplier becomes less important when the modulus is large. It is still necessary to calculate the spectral index and make sure that the multiplier is not a bad one, but purely probabilistically it becomes extremely unlikely to encounter a bad multiplier when the modulus is larger than about 2&lt;sup&gt;64&lt;/sup&gt;.

Another flaw specific to LCGs is the short period of the low-order bits when ''m'' is chosen to be a power of 2. This can be mitigated by using a modulus larger than the required output, and using the most significant bits of the state.

Nevertheless, for some applications LCGs may be a good option. For instance, in an embedded system, the amount of memory available is often severely limited. Similarly, in an environment such as a [[video game console]] taking a small number of high-order bits of an LCG may well suffice.  (The low-order bits of LCGs when m is a power of 2 should never be relied on for any degree of randomness whatsoever.)  The low order bits go through very short cycles.  In particular, any full-cycle LCG, when m is a power of 2, will produce alternately odd and even results.

LCGs should be evaluated very carefully for suitability in non-cryptographic applications where high-quality [[randomness]] is critical. For Monte Carlo simulations, an LCG must use a modulus greater and preferably much greater than the cube of the number of random samples which are required. This means, for example, that a (good) 32-bit LCG can be used to obtain about a thousand random numbers; a 64-bit LCG is good for about 2&lt;sup&gt;21&lt;/sup&gt; random samples (a little over two million), etc. For this reason, in practice LCGs are not suitable for large-scale Monte Carlo simulations.

==Sample Python code==
The following is an implementation of an LCG in [[Python (programming language)|Python]]:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
def lcg(modulus, a, c, seed):
    &quot;&quot;&quot;Linear congruential generator.&quot;&quot;&quot;
    while True:
        seed = (a * seed + c) % modulus
        yield seed
&lt;/syntaxhighlight&gt;

==Sample Free Pascal code==
Free Pascal uses a [[Mersenne Twister]] as its default pseudo random number generator whereas Delphi uses a LCG. Here is a Delphi compatible example in [[Free Pascal]] based on the information in the table above. Given the same RandSeed value it generates the same sequence of random numbers as Delphi.

&lt;syntaxhighlight lang=&quot;pascal&quot;&gt;
unit lcg_random;
{$ifdef fpc}{$mode delphi}{$endif}
interface

function LCGRandom: extended; overload;inline;
function LCGRandom(const range:longint):longint;overload;inline;

implementation
function IM:cardinal;inline;
begin
  RandSeed := RandSeed * 134775813 + 1;
  Result := RandSeed;
end;

function LCGRandom: extended; overload;inline;
begin
  Result := IM * 2.32830643653870e-10;
end;

function LCGRandom(const range:longint):longint;overload;inline;
begin
  Result := IM * range shr 32;
end;&lt;/syntaxhighlight&gt;

Like all pseudorandom number generators, a LCG needs to store state and alter it each time it generates a new number. Multiple threads may access this state simultaneously causing a race condition. Implementations should use different state each with unique initialization for different threads to avoid equal sequences of random numbers on simultaneously executing threads.

==LCG derivatives==
There are several generators which are linear congruential generators in a different form, and thus the techniques used to analyze LCGs can be applied to them.
