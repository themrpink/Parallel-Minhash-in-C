The problem of solving a system of linear inequalities dates back at least as far as [[Joseph Fourier|Fourier]], who in 1827 published a method for solving them,&lt;ref name=&quot;SierksmaZwols2015&quot;&gt;{{cite book|author1=Gerard Sierksma|author2=Yori Zwols|title=Linear and Integer Optimization: Theory and Practice|edition=3rd|year=2015|publisher=CRC Press|isbn=978-1498710169|page=1}}&lt;/ref&gt; and after whom the method of [[Fourier–Motzkin elimination]] is named.

In 1939 a linear programming formulation of a problem that is equivalent to the general linear programming problem was given by the [[Soviet Union|Soviet]] [[mathematician]] and [[economist]] [[Leonid Kantorovich]], who also proposed a method for solving it.&lt;ref name=&quot;Schrijver1998&quot;&gt;{{cite book|author=Alexander Schrijver|title=Theory of Linear and Integer Programming|year=1998|publisher=John Wiley &amp; Sons|isbn=978-0-471-98232-6|pages=221–222}}&lt;/ref&gt; It is a way he developed, during [[World War II]], to plan expenditures and returns in order to reduce costs of the army and to increase losses imposed on the enemy.{{Citation needed|date=August 2017}} Kantorovich's work was initially neglected in the [[USSR]].&lt;ref name=&quot;dantzig1982&quot;&gt;{{cite journal|url = http://www.dtic.mil/cgi-bin/GetTRDoc?Location=U2&amp;doc=GetTRDoc.pdf&amp;AD=ADA112060|title = Reminiscences about the origins of linear programming|author=George B. Dantzig|date = April 1982|journal = Operations Research Letters|volume = 1|issue = 2|pages = 43–48|doi = 10.1016/0167-6377(82)90043-8}}&lt;/ref&gt; About the same time as Kantorovich, the Dutch-American economist [[Tjalling Koopmans|T. C. Koopmans]] formulated classical economic problems as linear programs. Kantorovich and Koopmans later shared the 1975 [[Nobel prize in economics]].&lt;ref name=&quot;SierksmaZwols2015&quot; /&gt; In 1941, [[Frank Lauren Hitchcock]] also formulated transportation  problems as linear programs and gave a solution very similar to the later [[simplex method]].&lt;ref name=&quot;Schrijver1998&quot; /&gt; Hitchcock had died in 1957 and the Nobel prize is not awarded posthumously.

During 1946–1947, [[George Dantzig|George B. Dantzig]] independently developed general linear programming formulation to use for planning problems in the US Air Force.&lt;ref name=&quot;:0&quot;&gt;{{Cite book|title=Linear programming|last1=Dantzig|first1=George B.|last2=Thapa|first2=Mukund Narain|date=1997|publisher=Springer|isbn=0387948333|location=New York|page=xxvii|oclc=35318475}}&lt;/ref&gt; In 1947, Dantzig also invented the [[Simplex algorithm|simplex method]] that for the first time efficiently tackled the linear programming problem in most cases&lt;ref name=&quot;:0&quot; /&gt;. When Dantzig arranged a meeting with [[John von Neumann]] to discuss his simplex method, Neumann immediately conjectured the theory of [[#Duality|duality]] by realizing that the problem he had been working in [[game theory]] was equivalent&lt;ref name=&quot;:0&quot; /&gt;. Dantzig provided formal proof in an unpublished report &quot;A Theorem on Linear Inequalities&quot; on January 5, 1948.&lt;ref name=&quot;dantzig1982&quot;/&gt; Dantzig's work was made available to public in 1951. In the post-war years, many industries applied it in their daily planning.

Dantzig's original example was to find the best assignment of 70 people to 70 jobs. The computing power required to test all the permutations to select the best assignment is vast; the number of possible configurations exceeds the [[Abundance of the chemical elements|number of particles]] in the [[observable universe]]. However, it takes only a moment to find the optimum solution by posing the problem as a linear program and applying the [[simplex algorithm]]. The theory behind linear programming drastically reduces the number of possible solutions that must be checked.

The linear programming problem was first shown to be solvable in polynomial time by [[Leonid Khachiyan]] in 1979,&lt;ref name = &quot;khachiyan79&quot;&gt;{{cite journal|title = A Polynomial Algorithm for Linear Programming|author = Leonid Khachiyan|date = 1979|journal = Doklady Akademii Nauk SSSR|volume=224|issue=5|pages=1093–1096}}&lt;/ref&gt; but a larger theoretical and practical breakthrough in the field came in 1984 when [[Narendra Karmarkar]] introduced a new [[interior-point method]] for solving linear-programming problems.&lt;ref name = &quot;karmarkar84&quot; &gt;{{cite journal|title = A New Polynomial-Time Algorithm for Linear Programming|author = Narendra Karmarkar|date = 1984|journal = Combinatorica|volume=4|issue = 4|pages=373–395|doi = 10.1007/BF02579150|s2cid = 7257867}}&lt;/ref&gt;

== Uses ==
Linear programming is a widely used field of optimization for several reasons. Many practical problems in [[operations research]] can be expressed as linear programming problems.&lt;ref name=&quot;dantzig1982&quot;/&gt; Certain special cases of linear programming, such as ''[[network flow problem|network flow]]'' problems and [[multi-commodity flow problem|''multicommodity flow'' problems]] are considered important enough to have generated much research on specialized algorithms for their solution. A number of algorithms for other types of optimization problems work by solving LP problems as sub-problems. Historically, ideas from linear programming have inspired many of the central concepts of optimization theory, such as ''duality,'' ''decomposition,'' and the importance of ''convexity'' and its generalizations. Likewise, linear programming was heavily used in the early formation of [[microeconomics]] and it is currently utilized in company management, such as planning, production, transportation, technology and other issues. Although the modern management issues are ever-changing, most companies would like to [[profit maximization|maximize profits]] and minimize costs with limited resources. Therefore, many issues can be characterized as linear programming problems.

== Standard form ==
''Standard form'' is the usual and most intuitive form of describing a linear programming problem. It consists of the following three parts:
* A '''linear function to be maximized'''
: e.g. &lt;math&gt; f(x_{1},x_{2}) = c_1 x_1 + c_2 x_2&lt;/math&gt;
* '''Problem constraints''' of the following form
: e.g.
:: &lt;math&gt;\begin{matrix}
  a_{11} x_1 + a_{12} x_2 &amp;\leq b_1 \\
  a_{21} x_1 + a_{22} x_2 &amp;\leq b_2 \\
  a_{31} x_1 + a_{32} x_2 &amp;\leq b_3 \\
\end{matrix}&lt;/math&gt;
* '''Non-negative variables'''
: e.g.
:: &lt;math&gt;\begin{matrix}
 x_1 \geq 0 \\
 x_2 \geq 0
\end{matrix}&lt;/math&gt;

The problem is usually expressed in ''[[Matrix (mathematics)|matrix]] form'', and then becomes:
: &lt;math&gt;\max \{ \mathbf{c}^\mathrm{T} \mathbf{x} \;|\; A \mathbf{x} \leq \mathbf{b} \land \mathbf{x} \geq 0 \}&lt;/math&gt;

Other forms, such as minimization problems, problems with constraints on alternative forms, as well as problems involving negative [[variable (programming)|variables]] can always be rewritten into an equivalent problem in standard form.

=== Example ===
Suppose that a farmer has a piece of farm land, say ''L'' km&lt;sup&gt;2&lt;/sup&gt;, to be planted with either wheat or barley or some combination of the two. The farmer has a limited amount of fertilizer, ''F'' kilograms, and pesticide, ''P'' kilograms. Every square kilometer of wheat requires ''F''&lt;sub&gt;1&lt;/sub&gt; kilograms of fertilizer and ''P''&lt;sub&gt;1&lt;/sub&gt; kilograms of pesticide, while every square kilometer of barley requires ''F''&lt;sub&gt;2&lt;/sub&gt; kilograms of fertilizer and ''P''&lt;sub&gt;2&lt;/sub&gt; kilograms of pesticide. Let S&lt;sub&gt;1&lt;/sub&gt; be the selling price of wheat per square kilometer, and S&lt;sub&gt;2&lt;/sub&gt; be the selling price of barley. If we denote the area of land planted with wheat and barley by ''x''&lt;sub&gt;1&lt;/sub&gt; and ''x''&lt;sub&gt;2&lt;/sub&gt; respectively, then profit can be maximized by choosing optimal values for ''x''&lt;sub&gt;1&lt;/sub&gt; and ''x''&lt;sub&gt;2&lt;/sub&gt;. This problem can be expressed with the following linear programming problem in the standard form:
{|
|-
| colspan=&quot;2&quot; | Maximize: &lt;math&gt;S_1\cdot x_1+S_2\cdot x_2&lt;/math&gt;
| (maximize the revenue – revenue is the &quot;objective function&quot;)
|-
| Subject to:
| &lt;math&gt;x_1 + x_2\leq L&lt;/math&gt;
| (limit on total area)
|-
|
| &lt;math&gt;F_1\cdot x_1+F_2\cdot x_2\leq F&lt;/math&gt;
| (limit on fertilizer)
|-
|
| &lt;math&gt;P_1\cdot x_1 + P_2\cdot x_2\leq P&lt;/math&gt;
| (limit on pesticide)
|-
|
| &lt;math&gt;x_1\geq 0, x_2\geq 0&lt;/math&gt;
| (cannot plant a negative area).
|}

In matrix form this becomes:
: maximize &lt;math&gt;\begin{bmatrix} S_1 &amp; S_2 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} &lt;/math&gt;
: subject to &lt;math&gt;\begin{bmatrix} 1 &amp; 1 \\ F_1 &amp; F_2 \\ P_1 &amp; P_2 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} \le \begin{bmatrix} L \\ F \\ P \end{bmatrix}, \, \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} \ge \begin{bmatrix} 0 \\ 0 \end{bmatrix}. &lt;/math&gt;

== Augmented form (slack form) ==
Linear programming problems can be converted into an ''augmented form'' in order to apply the common form of the [[simplex algorithm]]. This form introduces non-negative ''[[slack variable]]s'' to replace inequalities with equalities in the constraints. The problems can then be written in the following [[block matrix]] form:
: Maximize &lt;math&gt;z&lt;/math&gt;:
: &lt;math&gt;
  \begin{bmatrix}
    1 &amp; -\mathbf{c}^T &amp; 0 \\
    0 &amp; \mathbf{A} &amp; \mathbf{I}
  \end{bmatrix}
  \begin{bmatrix}
    z \\ \mathbf{x} \\ \mathbf{s}
  \end{bmatrix} =
  \begin{bmatrix}
    0 \\ \mathbf{b}
  \end{bmatrix}
&lt;/math&gt;
:&lt;math&gt;\mathbf{x} \ge  0, \mathbf{s} \ge 0&lt;/math&gt;
where &lt;math&gt;\mathbf{s}&lt;/math&gt; are the newly introduced slack variables, &lt;math&gt;\mathbf{x}&lt;/math&gt; are the decision variables, and &lt;math&gt;z&lt;/math&gt; is the variable to be maximized.

=== Example ===
The example above is converted into the following augmented form:
:{|
|-
| colspan=&quot;2&quot; | Maximize: &lt;math&gt;S_1\cdot x_1+S_2\cdot x_2&lt;/math&gt;
| (objective function)
|-
| subject to:
| &lt;math&gt;x_1 + x_2 + x_3 = L&lt;/math&gt;
| (augmented constraint)
|-
|
| &lt;math&gt;F_1\cdot x_1+F_2\cdot x_2 + x_4 = F&lt;/math&gt;
| (augmented constraint)
|-
|
| &lt;math&gt;P_1\cdot x_1 + P_2\cdot x_2 + x_5 = P&lt;/math&gt;
| (augmented constraint)
|-
|
| &lt;math&gt;x_1,x_2,x_3,x_4,x_5 \ge 0.&lt;/math&gt;
|}
where &lt;math&gt;x_3, x_4, x_5&lt;/math&gt; are (non-negative) slack variables, representing in this example the unused area, the amount of unused fertilizer, and the amount of unused pesticide.

In matrix form this becomes:
: Maximize &lt;math&gt;z&lt;/math&gt;:
: &lt;math&gt;
  \begin{bmatrix}
    1 &amp; -S_1 &amp; -S_2 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp;   1    &amp;   1    &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp;  F_1  &amp;  F_2  &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp;  P_1    &amp; P_2 &amp; 0 &amp; 0 &amp; 1 \\
  \end{bmatrix}
  \begin{bmatrix}
    z \\ x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
  \end{bmatrix} =
  \begin{bmatrix}
    0 \\ L \\ F \\ P
  \end{bmatrix}, \,
  \begin{bmatrix}
    x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
  \end{bmatrix} \ge 0.
&lt;/math&gt;

== Duality ==
{{Main|Dual linear program}}
Every linear programming problem, referred to as a ''primal'' problem, can be converted into a [[dual problem]], which provides an upper bound to the optimal value of the primal problem. In matrix form, we can express the ''primal'' problem as:

: Maximize '''c'''&lt;sup&gt;T&lt;/sup&gt;'''x'''  subject to ''A'''''x''' ≤ '''b''', '''x''' ≥ 0;
:: with the corresponding '''symmetric''' dual problem,
: Minimize  '''b'''&lt;sup&gt;T&lt;/sup&gt;'''y'''  subject to ''A''&lt;sup&gt;T&lt;/sup&gt;'''y''' ≥ '''c''', '''y''' ≥ 0.

An alternative primal formulation is:

: Maximize '''c'''&lt;sup&gt;T&lt;/sup&gt;'''x''' subject to ''A'''''x''' ≤ '''b''';
:: with the corresponding '''asymmetric''' dual problem,
: Minimize  '''b'''&lt;sup&gt;T&lt;/sup&gt;'''y''' subject to ''A''&lt;sup&gt;T&lt;/sup&gt;'''y''' = '''c''', '''y''' ≥ 0.

There are two ideas fundamental to duality theory. One is the fact that (for the symmetric dual) the dual of a dual linear program is the original primal linear program. Additionally, every feasible solution for a linear program gives a bound on the optimal value of the objective function of its dual.  The [[weak duality]] theorem states that the objective function value of the dual at any feasible solution is always greater than or equal to the objective function value of the primal at any feasible solution. The [[strong duality]] theorem states that if the primal has an optimal solution, '''x'''&lt;sup&gt;*&lt;/sup&gt;, then the dual also has an optimal solution, '''y'''&lt;sup&gt;*&lt;/sup&gt;, and '''c'''&lt;sup&gt;T&lt;/sup&gt;'''x'''&lt;sup&gt;*&lt;/sup&gt;='''b'''&lt;sup&gt;T&lt;/sup&gt;'''y'''&lt;sup&gt;*&lt;/sup&gt;.

A linear program can also be unbounded or infeasible. Duality theory tells us that if the primal is unbounded then the dual is infeasible by the weak duality theorem. Likewise, if the dual is unbounded, then the primal must be infeasible. However, it is possible for both the dual and the primal to be infeasible.  See [[dual linear program]] for details and several more examples.

== Variations ==

=== Covering/packing dualities ===
&lt;!--Linked from [[Template:Covering/packing-problem pairs]]--&gt;
{{Covering/packing-problem pairs}}

A [[Covering problem|covering LP]] is a linear program of the form:
: Minimize:  &lt;big&gt;'''b'''&lt;sup&gt;T&lt;/sup&gt;'''y'''&lt;/big&gt;,
: subject to: &lt;big&gt;''A''&lt;sup&gt;T&lt;/sup&gt;'''y''' ≥ '''c''', '''y''' ≥ 0&lt;/big&gt;,
such that the matrix ''A'' and the vectors '''b''' and '''c''' are non-negative.

The dual of a covering LP is a [[Packing problem|packing LP]], a linear program of the form:
: Maximize: &lt;big&gt;'''c'''&lt;sup&gt;T&lt;/sup&gt;'''x'''&lt;/big&gt;,
: subject to: &lt;big&gt;''A'''''x''' ≤ '''b''', '''x''' ≥ 0&lt;/big&gt;,
such that the matrix ''A'' and the vectors '''b''' and '''c''' are non-negative.

==== Examples ====
Covering and packing LPs commonly arise as a [[linear programming relaxation]] of a combinatorial problem and are important in the study of [[approximation algorithms]].&lt;ref&gt;{{harvtxt|Vazirani|2001|p=112}}&lt;/ref&gt; For example, the LP relaxations of the [[Set packing|set packing problem]], the [[independent set problem]], and the [[Matching (graph theory)|matching problem]] are packing LPs. The LP relaxations of the [[set cover problem]], the [[vertex cover problem]], and the [[dominating set problem]] are also covering LPs.

Finding a [[fractional coloring]] of a [[Graph (discrete mathematics)|graph]] is another example of a covering LP. In this case, there is one constraint for each vertex of the graph and one variable for each [[Independent set (graph theory)|independent set]] of the graph.

== Complementary slackness ==
It is possible to obtain an optimal solution to the dual when only an optimal solution to the primal is known using the complementary slackness theorem. The theorem states:

Suppose that '''x'''&amp;nbsp;=&amp;nbsp;('''x'''&lt;sub&gt;1&lt;/sub&gt;,&amp;nbsp;'''x'''&lt;sub&gt;2&lt;/sub&gt;,&amp;nbsp;...&amp;nbsp;,&amp;nbsp;'''x'''&lt;sub&gt;''n''&lt;/sub&gt;) is primal feasible and that '''y'''&amp;nbsp;=&amp;nbsp;('''y'''&lt;sub&gt;1&lt;/sub&gt;,&amp;nbsp;'''y'''&lt;sub&gt;2&lt;/sub&gt;,&amp;nbsp;...&amp;nbsp;,&amp;nbsp;'''y'''&lt;sub&gt;''m''&lt;/sub&gt;) is dual feasible. Let ('''w'''&lt;sub&gt;1&lt;/sub&gt;,&amp;nbsp;'''w'''&lt;sub&gt;2&lt;/sub&gt;,&amp;nbsp;...,&amp;nbsp;'''w'''&lt;sub&gt;''m''&lt;/sub&gt;) denote the corresponding primal slack variables, and let ('''z'''&lt;sub&gt;1&lt;/sub&gt;,&amp;nbsp;'''z'''&lt;sub&gt;2&lt;/sub&gt;,&amp;nbsp;...&amp;nbsp;,&amp;nbsp;'''z'''&lt;sub&gt;''n''&lt;/sub&gt;) denote the corresponding dual slack variables. Then '''x''' and '''y''' are optimal for their respective problems if and only if
* '''x'''&lt;sub&gt;''j''&lt;/sub&gt; '''z'''&lt;sub&gt;''j''&lt;/sub&gt;&amp;nbsp;=&amp;nbsp;0, for ''j''&amp;nbsp;=&amp;nbsp;1,&amp;nbsp;2,&amp;nbsp;...&amp;nbsp;,&amp;nbsp;''n'', and
* '''w'''&lt;sub&gt;''i''&lt;/sub&gt; '''y'''&lt;sub&gt;''i''&lt;/sub&gt;&amp;nbsp;=&amp;nbsp;0, for ''i''&amp;nbsp;=&amp;nbsp;1,&amp;nbsp;2,&amp;nbsp;...&amp;nbsp;,&amp;nbsp;''m''.

So if the ''i''-th slack variable of the primal is not zero, then the ''i''-th variable of the dual is equal to zero. Likewise, if the ''j''-th slack variable of the dual is not zero, then the ''j''-th variable of the primal is equal to zero.

This necessary condition for optimality conveys a fairly simple economic principle.  In standard form (when maximizing), if there is slack in a constrained primal resource (i.e., there are &quot;leftovers&quot;), then additional quantities of that resource must have no value.  Likewise, if there is slack in the dual (shadow) price non-negativity constraint requirement, i.e., the price is not zero, then there must be scarce supplies (no &quot;leftovers&quot;).

== Theory ==

=== Existence of optimal solutions ===
Geometrically, the linear constraints define the [[feasible region]], which is a [[convex set|convex]] [[polyhedron]]. A [[linear functional|linear function]] is a [[convex function]], which implies that every [[local minimum]] is a [[global minimum]]; similarly, a linear function is a [[concave function]], which implies that every [[local maximum]] is a [[global maximum]].

An optimal solution need not exist, for two reasons. First, if the constraints are inconsistent, then no feasible solution exists: For instance, the constraints '''x'''&amp;nbsp;≥&amp;nbsp;2 and '''x'''&amp;nbsp;≤&amp;nbsp;1 cannot be satisfied jointly; in this case, we say that the LP is ''infeasible''. Second, when the [[polytope]] is unbounded in the direction of the gradient of the objective function (where the gradient of the objective function is the vector of the coefficients of the objective function), then no optimal value is attained because it is always possible to do better than any finite value of the objective function.

=== Optimal vertices (and rays) of polyhedra ===
Otherwise, if a feasible solution exists and if the constraint set is bounded, then the optimum value is always attained on the boundary of the constraint set, by the ''[[maximum principle]]'' for ''[[convex function]]s'' (alternatively, by the ''minimum'' principle for ''[[concave function]]s'') since linear functions are both convex and concave. However, some problems have distinct optimal solutions; for example, the problem of finding a feasible solution to a system of linear inequalities is a linear programming problem in which the objective function is the zero function (that is, the constant function taking the value zero everywhere). For this feasibility problem with the zero-function for its objective-function, if there are two distinct solutions, then every convex combination of the solutions is a solution.

The vertices of the polytope are also called ''basic feasible solutions''. The reason for this choice of name is as follows. Let ''d'' denote the number of variables. Then the fundamental theorem of linear inequalities implies (for feasible problems) that for every vertex '''x'''&lt;sup&gt;*&lt;/sup&gt; of the LP feasible region, there exists a set of ''d'' (or fewer) inequality constraints from the LP such that, when we treat those ''d'' constraints as equalities, the unique solution is '''x'''&lt;sup&gt;*&lt;/sup&gt;. Thereby we can study these vertices by means of looking at certain subsets of the set of all constraints (a discrete set), rather than the continuum of LP solutions. This principle underlies the [[simplex algorithm]] for solving linear programs.

== Algorithms ==
{{See also|List of numerical analysis topics#Linear programming}}

[[File:Linear Programming Feasible Region.svg|frame|In a linear programming problem, a series of linear constraints produces a [[Convex set|convex]] [[feasible region]] of possible values for those variables. In the two-variable case this region is in the shape of a convex [[simple polygon]].]]

=== Basis exchange algorithms ===

==== Simplex algorithm of Dantzig ====

The [[simplex algorithm]], developed by [[George Dantzig]] in 1947, solves LP problems by constructing a feasible solution at a vertex of the [[polytope]] and then walking along a path on the edges of the polytope to vertices with non-decreasing values of the objective function until an optimum is reached for sure. In many practical problems, &quot;[[Simplex algorithm#Degeneracy: stalling and cycling|stalling]]&quot; occurs: many pivots are made with no increase in the objective function.&lt;ref name=&quot;DT03&quot;&gt;{{harvtxt|Dantzig|Thapa|2003}}&lt;/ref&gt;&lt;ref name=&quot;Padberg&quot;&gt;{{harvtxt|Padberg|1999}}&lt;/ref&gt; In rare practical problems, the usual versions of the simplex algorithm may actually &quot;cycle&quot;.&lt;ref name=&quot;Padberg&quot; /&gt; To avoid cycles, researchers developed new pivoting rules.&lt;ref name=&quot;Bland&quot;&gt;{{harvtxt|Bland|1977}}&lt;/ref&gt;&lt;ref name=&quot;Murty&quot;&gt;{{harvtxt|Murty|1983}}&lt;/ref&gt;&lt;ref name=&quot; DT03&quot; /&gt;&lt;ref name=&quot; Padberg&quot; /&gt;&lt;ref name=&quot;PS&quot;&gt;{{harvtxt|Papadimitriou|Steiglitz|}}&lt;/ref&gt;&lt;ref name=&quot;FukudaTerlaky&quot; /&gt;

In practice, the simplex [[algorithm]] is quite efficient and can be guaranteed to find the global optimum if certain precautions against ''cycling'' are taken. The simplex algorithm has been proved to solve &quot;random&quot; problems efficiently, i.e. in a cubic number of steps,&lt;ref&gt;{{harvtxt|Borgwardt|1987}}&lt;/ref&gt; which is similar to its behavior on practical problems.&lt;ref name=&quot;DT03&quot; /&gt;&lt;ref name=&quot;Todd&quot;&gt;{{harvtxt|Todd|2002}}&lt;/ref&gt;

However, the simplex algorithm has poor worst-case behavior: Klee and Minty constructed a family of linear programming problems for which the simplex method takes a number of steps exponential in the problem size.&lt;ref name=&quot;DT03&quot; /&gt;&lt;ref name=&quot;Murty&quot; /&gt;&lt;ref name=&quot;PS &quot; /&gt; In fact, for some time it was not known whether the linear programming problem was solvable in [[polynomial time]], i.e. of [[P (complexity)|complexity class P]].

==== Criss-cross algorithm ====
Like the simplex algorithm of Dantzig, the [[criss-cross algorithm]] is a basis-exchange algorithm that pivots between bases. However, the criss-cross algorithm need not maintain feasibility, but can pivot rather from a feasible basis to an infeasible basis. The criss-cross algorithm does not have [[time complexity|polynomial time-complexity]] for linear programming. Both algorithms visit all&amp;nbsp;2&lt;sup&gt;''D''&lt;/sup&gt; corners of a (perturbed) [[unit cube|cube]] in dimension&amp;nbsp;''D'', the [[Klee–Minty cube]], in the [[worst-case complexity|worst case]].&lt;ref name=&quot;FukudaTerlaky&quot;&gt;{{cite journal|first1=Komei|last1=Fukuda|first2=Tamás|last2=Terlaky|title=Criss-cross methods: A fresh view on pivot algorithms |journal=Mathematical Programming, Series B|volume=79|number=1–3|pages=369–395|editor=Thomas M. Liebling |editor2=Dominique de Werra|year=1997|doi=10.1007/BF02614325|mr=1464775|citeseerx=10.1.1.36.9373|s2cid=2794181}}&lt;/ref&gt;&lt;ref name=&quot;Roos&quot;&gt;{{cite journal|last=Roos|first=C.|title=An exponential example for Terlaky's pivoting rule for the criss-cross simplex method|journal=Mathematical Programming|volume=46|year=1990|series=Series A|doi=10.1007/BF01585729|mr=1045573 |issue=1|pages=79–84|s2cid=33463483}}&lt;/ref&gt;

=== Interior point ===
In contrast to the simplex algorithm, which finds an optimal solution by traversing the edges between vertices on a polyhedral set, interior-point methods move through the interior of the feasible region.

==== Ellipsoid algorithm, following Khachiyan ====
This is the first [[worst-case complexity|worst-case]] [[polynomial-time]] algorithm ever found for linear programming.  To solve a problem which has ''n'' variables and can be encoded in ''L'' input bits, this algorithm runs in &lt;math&gt; O(n^6 L) &lt;/math&gt; time.&lt;ref name = &quot;khachiyan79&quot; /&gt; [[Leonid Khachiyan]] solved this long-standing complexity issue in 1979 with the introduction of the [[ellipsoid method]]. The convergence analysis has (real-number) predecessors, notably the [[iterative method]]s developed by [[Naum Z. Shor]] and the [[approximation algorithm]]s by Arkadi Nemirovski and D. Yudin.

==== Projective algorithm of Karmarkar ====
{{main|Karmarkar's algorithm}}
Khachiyan's algorithm was of landmark importance for establishing the polynomial-time solvability of linear programs.  The algorithm was not a computational break-through, as the simplex method is more efficient for all but specially constructed families of linear programs.

However, Khachiyan's algorithm inspired new lines of research in linear programming. In 1984, [[Narendra Karmarkar|N. Karmarkar]] proposed a&lt;!-- n interior-point --&gt; [[projective method]] for linear programming.  Karmarkar's algorithm&lt;ref name = &quot;karmarkar84&quot; /&gt; improved on Khachiyan's&lt;ref name = &quot;khachiyan79&quot; /&gt; worst-case polynomial bound (giving &lt;math&gt;O(n^{3.5}L)&lt;/math&gt;). Karmarkar claimed that his algorithm was much faster in practical LP than the simplex method, a claim that created great interest in interior-point methods.&lt;ref name=&quot;Strang&quot;&gt;{{cite journal|last=Strang|first=Gilbert|author-link=Gilbert Strang|title=Karmarkar's algorithm and its place in applied mathematics|journal=[[The Mathematical Intelligencer]]|date=1 June 1987|issn=0343-6993|pages=4–10|volume=9|doi=10.1007/BF03025891|mr=883185|issue=2|s2cid=123541868}}&lt;/ref&gt; Since Karmarkar's discovery, many interior-point methods have been proposed and analyzed.

==== Vaidya's 87 algorithm ====

In 1987, Vaidya proposed an algorithm that runs in &lt;math&gt; O(n^3) &lt;/math&gt; time&lt;ref&gt;{{cite conference|title= An algorithm for linear programming which requires &lt;math&gt;{O} (((m+ n) n^2+(m+ n)^{1.5} n) L)&lt;/math&gt; arithmetic operations | conference = 28th Annual IEEE Symposium on Foundations of Computer Science | series = FOCS |last1=Vaidya|first1=Pravin M. |year=1987 }}&lt;/ref&gt;.

==== Vaidya's 89 algorithm ====
In 1989, Vaidya developed an algorithm that runs in &lt;math&gt;O(n^{2.5})&lt;/math&gt; time.&lt;ref&gt;{{cite conference|title= Speeding-up linear programming using fast matrix multiplication | conference = 30th Annual Symposium on Foundations of Computer Science| series = FOCS |last1=Vaidya|first1=Pravin M. |year=1989| doi = 10.1109/SFCS.1989.63499 }}&lt;/ref&gt; Formally speaking, the algorithm takes &lt;math&gt;O( (n+d)^{1.5} n L)&lt;/math&gt; arithmetic operations in the worst case, where &lt;math&gt;d&lt;/math&gt; is the number of constraints, &lt;math&gt; n &lt;/math&gt; is the number of variables, and &lt;math&gt;L&lt;/math&gt; is the number of bits.
