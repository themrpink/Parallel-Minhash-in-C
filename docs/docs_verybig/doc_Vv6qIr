In turn, finding such a &lt;math&gt; b &lt;/math&gt; is reduced to finding an element &lt;math&gt; a &lt;/math&gt; of even period with a certain additional property (as explained below, it is required that the condition of Step 6 of the classical part does not hold). The quantum algorithm is used for finding the period of randomly chosen elements &lt;math&gt; a &lt;/math&gt;, as this is a difficult problem on a classical computer.

Shor's algorithm consists of two parts:

# A reduction, which can be done on a classical computer, of the factoring problem to the problem of [[Order (group theory)|order]]-finding.
# A quantum algorithm to solve the order-finding problem.

=== Classical part ===
{{ordered list
| Pick a random number &lt;math&gt; 1 &lt; a &lt; N &lt;/math&gt;.
| Compute &lt;math&gt; \gcd(a,N) &lt;/math&gt;, the [[greatest common divisor]] of &lt;math&gt; a &lt;/math&gt; and &lt;math&gt; N &lt;/math&gt;. This may be done using the [[Euclidean algorithm]].
| If &lt;math&gt; \gcd(a,N) \neq 1 &lt;/math&gt;, then this number is a [[nontrivial]] factor of &lt;math&gt; N &lt;/math&gt;, so we are done.
| Otherwise, use the quantum period-finding subroutine (below) to find &lt;math&gt; r &lt;/math&gt;, which denotes the [[periodic function|period]] of the following function:
:&lt;math&gt; f(x) = a^{x} \bmod N. &lt;/math&gt;
This is the order &lt;math&gt; r &lt;/math&gt; of &lt;math&gt; a &lt;/math&gt; in the [[Group (mathematics)|group]] [[Multiplicative group of integers modulo n|&lt;math&gt; (\mathbb{Z}_{N})^{\times} &lt;/math&gt;]], which is the smallest positive integer &lt;math&gt; r &lt;/math&gt; for which &lt;math&gt; f(x + r) = f(x) &lt;/math&gt;, or &lt;math&gt; f(x + r) = a^{x + r} \bmod N \equiv a^{x} \bmod N &lt;/math&gt;. By [[Euler's Theorem]], &lt;math&gt; r &lt;/math&gt; divides &lt;math&gt; \varphi(N) &lt;/math&gt;, where &lt;math&gt; \varphi &lt;/math&gt; denotes [[Euler's totient function]].
| If &lt;math&gt; r &lt;/math&gt; is odd, then go back to step 1.
| If &lt;math&gt; a^{r / 2} \equiv - 1 (\bmod N) &lt;/math&gt;, then go back to step 1.
| Otherwise, both &lt;math&gt; \gcd(a^{r / 2} + 1,N) &lt;/math&gt; and &lt;math&gt; \gcd(a^{r / 2} - 1,N) &lt;/math&gt; are nontrivial factors of &lt;math&gt; N &lt;/math&gt;, so we are done.
}}

For example: Given &lt;math&gt; N = 15 &lt;/math&gt;, &lt;math&gt; a = 7 &lt;/math&gt;, and &lt;math&gt; r = 4&lt;/math&gt;, we have &lt;math&gt; \gcd(7^{2} \pm 1,15) = \gcd(49 \pm 1,15) &lt;/math&gt;, where &lt;math&gt; \gcd(48,15) = 3 &lt;/math&gt; and &lt;math&gt; \gcd(50, 15) = 5 &lt;/math&gt;. For &lt;math&gt; N &lt;/math&gt; that is a product of two distinct primes, &lt;math&gt; p &lt;/math&gt; and &lt;math&gt; q &lt;/math&gt;, the value of &lt;math&gt; \varphi(N) &lt;/math&gt; is just &lt;math&gt; N - p - q + 1 &lt;/math&gt;, which for &lt;math&gt; N = 15 &lt;/math&gt; is &lt;math&gt; 8 &lt;/math&gt;, and &lt;math&gt; r &lt;/math&gt; divides &lt;math&gt; 8 &lt;/math&gt;.

=== Quantum part: period-finding subroutine ===
{{Technical|section|date=February 2014}}
[[File:Shor's algorithm.svg|450px|thumb|center|Quantum subroutine in Shor's algorithm]]
The quantum circuits used for this algorithm are custom designed for each choice of &lt;math&gt; N &lt;/math&gt; and each choice of the random &lt;math&gt; a &lt;/math&gt; used in &lt;math&gt; f(x) = a^{x} \bmod N &lt;/math&gt;. Given &lt;math&gt; N &lt;/MATH&gt;, find &lt;math&gt; Q = 2^{q} &lt;/math&gt; such that &lt;math&gt; N^{2} \leq Q &lt; 2 N^{2} &lt;/math&gt;, which implies that &lt;math&gt; \dfrac{Q}{r} &gt; N &lt;/math&gt;. The input and output [[qubit]] registers need to hold superpositions of values from &lt;math&gt; 0 &lt;/math&gt; to &lt;math&gt; Q - 1 &lt;/math&gt;, and so have &lt;math&gt; q &lt;/math&gt; qubits each. Using what might appear to be twice as many qubits as necessary guarantees that there are at least &lt;math&gt; N &lt;/math&gt; different values of &lt;math&gt; x &lt;/math&gt; that produce the same &lt;math&gt; f(x) &lt;/math&gt;, even as the period &lt;math&gt; r &lt;/math&gt; approaches &lt;math&gt; \dfrac{N}{2} &lt;/math&gt;.

Proceed as follows:

{{ordered list
| Initialize the registers to

:&lt;math&gt;
  \frac{1}{\sqrt{Q}} \sum_{x = 0}^{Q - 1} | x \rangle
= \left(\frac{1}{\sqrt{2}} \sum_{x_{1} = 0}^{1} | x_{1} \rangle \right) \otimes \cdots \otimes \left(\frac{1}{\sqrt{2}} \sum_{x_{q} = 0}^{1} | x_{q} \rangle \right).
&lt;/math&gt;
where &lt;math&gt;\otimes&lt;/math&gt; denotes the [[tensor product]].

This initial state is a superposition of &lt;math&gt; Q &lt;/math&gt; states, and is easily obtained by generating &lt;math&gt; q &lt;/math&gt; independent [[qubit]]s, each a superposition of &lt;math&gt; 0 &lt;/math&gt; and &lt;math&gt; 1 &lt;/math&gt; states. We can accomplish this by initializing the qubits to the zero-position, and then applying the [[Hadamard gate]] in parallel to each of the &lt;math&gt; q &lt;/math&gt; qubits, where &lt;math&gt; 2^{q} = Q &lt;/math&gt;.

| Construct &lt;math&gt; f(x) &lt;/math&gt; as a quantum function and apply it to the above state, to obtain

:&lt;math&gt;
U_f | x, 0^q \rangle = | x,f(x) \rangle
&lt;/math&gt;

:&lt;math&gt;
U_f \frac{1}{\sqrt{Q}} \sum_{x = 0}^{Q - 1} | x, 0^q \rangle = \frac{1}{\sqrt{Q}} \sum_{x = 0}^{Q - 1} | x,f(x) \rangle
&lt;/math&gt;

This is still a superposition of &lt;math&gt; Q &lt;/math&gt; states. However, the &lt;math&gt; q + n &lt;/math&gt; qubits, i.e, the &lt;math&gt; q &lt;/math&gt; input qubits and &lt;math&gt; n &lt;/math&gt; (&lt;math&gt; &gt; {\log_{2}}(N) &lt;/math&gt;) output qubits, are now entangled or not [[Separable state|separable]], as the state cannot be written as a tensor product of states of individual qubits.

Importantly, the value containing the &lt;math&gt; r &lt;/math&gt; we are looking for is now stored in the phase of the input qubits &lt;math&gt; x &lt;/math&gt; as a result of &quot;phase kickback&quot;, where using qubits as control inputs to unitary gates alters the relative phase of the control qubits. &lt;ref name=&quot;quiskit-phase&quot;&gt;{{cite web |last1=Qiskit authors |title=Qiskit Textbook: Quantum Phase Estimation |url=https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html |publisher=IBM |access-date=7 November 2020}}&lt;/ref&gt;

| Apply the inverse [[quantum Fourier transform]] to the input register. This transform (operating on a superposition of &lt;math&gt; Q = 2^{q} &lt;/math&gt; states) uses a &lt;math&gt; Q &lt;/math&gt;-th [[root of unity]] [[Imaginary unit#i and −i|such as]] &lt;math&gt; \omega = e^{\frac{2 \pi i}{Q}} &lt;/math&gt; to distribute the amplitude of any given &lt;math&gt; | x \rangle &lt;/math&gt; state equally among all &lt;math&gt; Q &lt;/math&gt; of the &lt;math&gt; | y \rangle &lt;/math&gt; states, and to do so in a different way for each different &lt;math&gt; x &lt;/math&gt;. We thus obtain

:&lt;math&gt;
{U_{\operatorname{QFT}}}(| x \rangle) = \frac{1}{\sqrt{Q}} \sum_{y = 0}^{Q - 1} \omega^{x y} | y \rangle.
&lt;/math&gt;

This leads to the final state

:&lt;math&gt;
\frac{1}{Q} \sum_{x = 0}^{Q - 1} \sum_{y = 0}^{Q - 1} \omega^{x y} | y,f(x) \rangle.
&lt;/math&gt;

Now, we reorder this sum as

:&lt;math&gt;
\frac{1}{Q} \sum_{z = 0}^{N - 1} \sum_{y = 0}^{Q - 1} \left[ \sum_{x \in \{ 0,\ldots,Q - 1 \}; ~ f(x) = z} \omega^{x y} \right] | y,z \rangle.
&lt;/math&gt;

This is a superposition of many more than &lt;math&gt; Q &lt;/math&gt; states, but many fewer than &lt;math&gt; Q^{2} &lt;/math&gt; states, as there are fewer than &lt;math&gt; Q &lt;/math&gt; distinct values of &lt;math&gt; z = f(x) &lt;/math&gt;. Let

* &lt;math&gt; \omega = e^{\frac{2 \pi i}{Q}} &lt;/math&gt; be a &lt;math&gt; Q &lt;/math&gt;-th root of unity,
* &lt;math&gt; r &lt;/math&gt; be the period of &lt;math&gt; f &lt;/math&gt;,
* &lt;math&gt; x_{0} &lt;/math&gt; be the smallest of the &lt;math&gt; x \in \{ 0,\ldots,Q - 1 \} &lt;/math&gt; for which &lt;math&gt; f(x) = z &lt;/math&gt; (we have &lt;math&gt; x_{0} &lt; r &lt;/math&gt;), and
* write &lt;math&gt; m - 1 = \left\lfloor \frac{Q - x_{0} - 1}{r} \right\rfloor &lt;/math&gt;
* &lt;math&gt; b &lt;/math&gt; indexes these &lt;math&gt; x &lt;/math&gt;, running from &lt;math&gt; 0 &lt;/math&gt; to &lt;math&gt; m - 1 &lt;/math&gt;, so that &lt;math&gt; x_{0} + r b &lt; Q &lt;/math&gt;.

Then &lt;math&gt; \omega^{r y} &lt;/math&gt; is a unit vector in the complex plane (&lt;math&gt; \omega &lt;/math&gt; is a root of unity, and &lt;math&gt; r &lt;/math&gt; and &lt;math&gt; y &lt;/math&gt; are integers), and the coefficient of &lt;math&gt; \dfrac{1}{Q} \left| y,z \right\rangle &lt;/math&gt; in the final state is

:&lt;math&gt;
  \sum_{x \in \{ 0,\ldots,Q - 1 \}; ~ f(x) = z} \omega^{x y}
= \sum_{b = 0}^{m - 1} \omega^{(x_{0} + r b) y}
= \omega^{x_{0} y} \sum_{b = 0}^{m - 1} \omega^{r b y}.
&lt;/math&gt;

Each term in this sum represents a ''different path to the same result'', and quantum [[Interference (wave propagation)|interference]] occurs — constructive when the unit vectors &lt;math&gt; \omega^{r y b} &lt;/math&gt; point in nearly the same direction in the complex plane, which requires that &lt;math&gt; \omega^{r y} &lt;/math&gt; point along the [[positive real axis]].

| Perform a measurement. We obtain some outcome &lt;math&gt; y &lt;/math&gt; in the input register and some outcome &lt;math&gt; z &lt;/math&gt; in the output register. As &lt;math&gt; f &lt;/math&gt; is periodic, the probability of measuring some state &lt;math&gt; | y,z \rangle &lt;/math&gt; is given by

:&lt;math&gt;
Pr(| y, z \rangle)= \left| \frac{1}{Q} \sum_{x \in \{ 0,\ldots,Q - 1 \}; ~ f(x) = z} \omega^{x y} \right|^{2}
= \frac{1}{Q^{2}} \left| \sum_{b = 0}^{m - 1} \omega^{(x_{0} + r b) y} \right|^{2}
= \frac{1}{Q^{2}} |\omega^{x_{0} y}|^{2}\left| \sum_{b = 0}^{m - 1} \omega^{b r y} \right|^{2} 
&lt;/math&gt;

:&lt;math&gt;
= \frac{1}{Q^{2}} \left| \sum_{b = 0}^{m - 1} \omega^{b r y} \right|^{2} = \frac{1}{Q^{2}} \frac{\omega^{m r y} - 1}{\omega^{r y} - 1} = \frac{1}{Q^{2}} \frac{\sin^2(\frac{\pi m r y}{Q})}{\sin^2(\frac{\pi r y}{Q})}
&lt;/math&gt;

Analysis now shows that this probability is higher the closer the unit vector &lt;math&gt; \omega^{r y} &lt;/math&gt; is to the positive real axis, or the closer &lt;math&gt; \dfrac{y r}{Q} &lt;/math&gt; is to an integer. Unless &lt;math&gt; r &lt;/math&gt; is a power of &lt;math&gt; 2 &lt;/math&gt;, it will not be a factor of &lt;math&gt; Q &lt;/math&gt;.

| Since &lt;math&gt; \frac{y r}{Q} &lt;/math&gt; is close to some integer &lt;math&gt; c &lt;/math&gt;, the known value &lt;math&gt; \dfrac{y}{Q} &lt;/math&gt; is close to the unknown value &lt;math&gt; \dfrac{c}{r} &lt;/math&gt;. Performing [classical] [[Continued fraction|continued fraction expansion]] on &lt;math&gt; \dfrac{y}{Q} &lt;/math&gt; allows us to find approximations &lt;math&gt; \dfrac{d}{s} &lt;/math&gt; of it that satisfy two conditions:
{{ordered list
 | list-style-type = upper-alpha
 | &lt;math&gt; s &lt; N &lt;/math&gt;.
 | &lt;math&gt; \left| \dfrac{y}{Q} - \dfrac{d}{s} \right| &lt; \dfrac{1}{2 Q} &lt;/math&gt;.
}}

Given these multiple conditions (and assuming &lt;math&gt; \dfrac{d}{s} &lt;/math&gt; is [[irreducible fraction|irreducible]]), &lt;math&gt; s &lt;/math&gt; is very likely to be the appropriate period &lt;math&gt; r &lt;/math&gt;, or at least a factor of it.

| Check (classically) if &lt;math&gt; f(x) = f(x + s) \Leftrightarrow a^{s} \equiv 1 \bmod N &lt;/math&gt;. If so, then we are done.

| Otherwise, (classically) obtain more candidates for &lt;math&gt; r &lt;/math&gt; by using multiples of &lt;math&gt; s &lt;/math&gt;, or by using other &lt;math&gt; s &lt;/math&gt; with &lt;math&gt; \dfrac{d}{s} &lt;/math&gt; near &lt;math&gt; \dfrac{y}{Q} &lt;/math&gt;. If any candidate works, then we are done.

| Otherwise, try again starting from step 1 of this subroutine.
}}

== Explanation of the algorithm ==
The algorithm is composed of two parts. The first part of the algorithm turns the factoring problem into the problem of finding the period of a function and may be implemented classically. The second part finds the period using the quantum Fourier transform and is responsible for the quantum speedup.

=== Obtaining factors from period ===
The integers less than &lt;math&gt; N &lt;/math&gt; and [[coprime]] with &lt;math&gt; N &lt;/math&gt; form the [[multiplicative group of integers modulo n|multiplicative group of integers modulo &lt;math&gt; N &lt;/math&gt;]], which is a finite abelian [[group (mathematics)|group]] &lt;math&gt; G &lt;/math&gt;. The size of this group is given by &lt;math&gt; \varphi(N) &lt;/math&gt;. By the end of step 3, we have an integer &lt;math&gt; a &lt;/math&gt; in this group. As the group is finite, &lt;math&gt; a &lt;/math&gt; must have a finite order &lt;math&gt; r &lt;/math&gt;, which is the smallest positive integer such that

:&lt;math&gt;
a^{r} \equiv 1 \bmod N.
&lt;/math&gt;

Therefore, &lt;math&gt; N &lt;/math&gt; [[divides]] &lt;math&gt; a^{r} - 1 &lt;/math&gt; (also written &lt;math&gt; N \mid a^{r} - 1 &lt;/math&gt;). Suppose that we are able to obtain &lt;math&gt; r &lt;/math&gt; and that it is even. (If &lt;math&gt; r &lt;/math&gt; is odd, then see step 5.) Now &lt;math&gt; b \equiv a^{r / 2} \bmod N &lt;/math&gt; is a square root of &lt;math&gt; 1 &lt;/math&gt; modulo &lt;math&gt; N &lt;/math&gt; that is different from &lt;math&gt; 1 &lt;/math&gt;. This is because &lt;math&gt; r &lt;/math&gt; is the order of &lt;math&gt; a &lt;/math&gt; modulo &lt;math&gt; N &lt;/math&gt;, so &lt;math&gt; a^{r / 2} \not\equiv 1 \bmod N &lt;/math&gt;, or else the order of &lt;math&gt; a &lt;/math&gt; in this group would be &lt;math&gt; \dfrac{r}{2} &lt;/math&gt;. If &lt;math&gt; a^{r / 2} \equiv - 1 \bmod N &lt;/math&gt;, then by step 6, we have to restart the algorithm with a different random number &lt;math&gt; a &lt;/math&gt;.

Eventually, we must hit an &lt;math&gt; a &lt;/math&gt; of order &lt;math&gt; r &lt;/math&gt; in &lt;math&gt; G &lt;/math&gt; such that &lt;math&gt; b \equiv a^{r / 2} \not\equiv 1,- 1 \bmod N &lt;/math&gt;. This is because such a &lt;math&gt; b &lt;/math&gt; is a square root of &lt;math&gt; 1 &lt;/math&gt; modulo &lt;math&gt; N &lt;/math&gt; other than &lt;math&gt; 1 &lt;/math&gt; and &lt;math&gt; - 1 &lt;/math&gt;, whose existence is guaranteed by the Chinese remainder theorem, as &lt;math&gt; N &lt;/math&gt; is not a prime power.

We claim that &lt;math&gt; d = \gcd(b - 1,N) &lt;/math&gt; is a proper factor of &lt;math&gt; N &lt;/math&gt;, i.e., &lt;math&gt; d \neq 1,N &lt;/math&gt;. In fact, if &lt;math&gt; d = N &lt;/math&gt;, then &lt;math&gt; N &lt;/math&gt; divides &lt;math&gt; b - 1 &lt;/math&gt;, so that &lt;math&gt; b \equiv 1 \bmod N &lt;/math&gt;, which goes against the construction of &lt;math&gt; b &lt;/math&gt;. If, on the other hand, &lt;math&gt; d = \gcd(b - 1,N) = 1 &lt;/math&gt;, then by [[Bézout's identity]], there are integers &lt;math&gt; u,v &lt;/math&gt; such that

:&lt;math&gt;
(b - 1) u + N v = 1.
&lt;/math&gt;

Multiplying both sides by &lt;math&gt; b + 1 &lt;/math&gt;, we obtain

:&lt;math&gt;
(b^{2} - 1) u + N (b + 1) v = b + 1.
&lt;/math&gt;

As &lt;math&gt; N &lt;/math&gt; divides &lt;math&gt; b^{2} - 1 \equiv a^{r} - 1 \bmod N &lt;/math&gt;, we find that &lt;math&gt; N &lt;/math&gt; divides &lt;math&gt; b + 1 &lt;/math&gt;, so that &lt;math&gt; b \equiv - 1 \bmod N &lt;/math&gt;, again contradicting the construction of &lt;math&gt; b &lt;/math&gt;.

Therefore, &lt;math&gt; d &lt;/math&gt; is the required proper factor of &lt;math&gt; N &lt;/math&gt;.

=== Finding the period ===
Shor's period-finding algorithm relies heavily on the ability of a [[quantum computer]] to be in many states simultaneously.

Physicists call this behavior a &quot;[[Quantum superposition|superposition]]&quot; of states. To compute the period of a function &lt;math&gt; f &lt;/math&gt;, we evaluate the function at all points simultaneously.

Quantum physics does not allow us to access all this information directly, however. A [[measurement in quantum mechanics|measurement]] will yield only one of all possible values, destroying all others. If not for the [[no cloning theorem]], we could first measure &lt;math&gt; f(x) &lt;/math&gt; without measuring &lt;math&gt; x &lt;/math&gt;, and then make a few copies of the resulting state (which is a superposition of states all having the same &lt;math&gt; f(x) &lt;/math&gt;). Measuring &lt;math&gt; x &lt;/math&gt; on these states would provide different &lt;math&gt; x &lt;/math&gt; values which give the same &lt;math&gt; f(x) &lt;/math&gt;, leading to the period. Because we cannot [[Quantum cloning|make exact copies of a quantum state]], this method does not work. Therefore, we have to carefully transform the superposition to another state that will return the correct answer with high probability. This is achieved by the [[quantum Fourier transform]].

Shor thus had to solve three &quot;implementation&quot; problems. All of them had to be implemented &quot;fast&quot;, which means that they can be implemented with a number of [[quantum gate]]s that is [[Time complexity#Polynomial time|polynomial]] in &lt;math&gt; \log N &lt;/math&gt;.
