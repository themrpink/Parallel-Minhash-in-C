===Own and borrowed capital===
Capital contributed by the owner or entrepreneur of a business, and obtained, for example, by means of savings or inheritance, is known as own capital or [[Equity (finance)|equity]], whereas that which is granted by another person or institution is called borrowed capital, and this must usually be paid back with interest. The ratio between debt and equity is named [[Leverage (finance)|leverage]]. It has to be optimized as a high leverage can bring a higher profit but create [[solvency]] risk.

'''Borrowed capital''' is capital that the business borrows from institutions or people, and includes debentures:

*[[Callable bond|Redeemable debenture]]s
*[[Irredeemable debentures]]&lt;!-- WAIT--WAIT! Before you remove the brackets, consider writing a new article! -- Paine --&gt;
* Debentures to bearer
* Ordinary [[debenture]]s
* bonds
* deposits
*loans
'''Own capital''' is capital that owners of a business (shareholders and partners, for example) provide:

* Preference shares/hybrid source of finance
** Ordinary preference shares
** Cumulative preference shares
** Participating preference shares
* Ordinary shares
* Bonus shares
* Founders' shares

These have preference over the equity shares. This means the payments made to the shareholders are first paid to the preference shareholder(s) and then to the equity shareholders.

== Instruments ==
A [[contract]] regarding any combination of [[capital asset]]s is called a [[financial instrument]], and may serve as a 
*[[medium of exchange]],
*[[standard of deferred payment]],
*[[unit of account]], or
*[[store of value]].

Most indigenous forms of money (wampum, shells, tally sticks and such) and the modern [[fiat money]] are only a &quot;symbolic&quot; storage of value and not a real storage of value like commodity money.

=== Valuation ===
Normally, a financial instrument is priced accordingly to the perception by capital market players of its expected return and risk. Unit of account functions may come into question if valuations of complex financial instruments vary drastically based on timing. The &quot;[[book value]]&quot;, &quot;[[mark-to-market]]&quot; and &quot;[[mark-to-future]]&quot;&lt;ref&gt;''[https://books.google.com/books?id=2w0bRIv7cygC&amp;pg=PA349&amp;lpg=PA349#PPP1,M1 The New Generation of Risk Management for Hedge Funds and Private Equity Investments]'', edited by Lars Jaeger, p.&amp;nbsp;349&lt;/ref&gt;  conventions are three different approaches to reconciling financial capital value units of account.

==Issuing and trading==

Like money, financial instruments may be &quot;backed&quot; by state [[military fiat]], [[credit (finance)|credit]] (i.e. [[social capital]] held by banks and their depositors), or [[commodity]] resources.  Governments generally closely control the supply of it and usually require some &quot;reserve&quot; be held by institutions granting credit.  Trading between various national [[currency]] instruments is conducted on a [[money market]].  Such trading reveals differences in probability of [[debt collection]] or [[store of value]] function of that currency, as assigned by traders.

When in forms other than money, financial capital may be traded on [[bond market]]s or [[Reinsurance|reinsurance markets]] with varying degrees of trust in the [[social capital]] (not just credits) of bond-issuers, insurers, and others who issue and trade in financial instruments.  When payment is deferred on any such instrument, typically an interest rate is higher than the standard interest rates paid by banks, or charged by the central bank on its money.  Often such instruments are called [[Fixed income|fixed-income instrument]]s if they have reliable payment schedules associated with the uniform rate of interest.  A variable-rate instrument, such as many [[Mortgage loan|consumer mortgages]], will reflect the standard rate for deferred payment set by the [[central bank]] [[prime rate]], increasing it by some fixed percentage. Other instruments, such as [[citizen entitlement]]s, e.g. &quot;[[U.S. Social Security]]&quot;, or other pensions, may be indexed to the rate of inflation, to provide a reliable value stream.

Trading in [[stock market]]s or [[commodity market]]s is actually trade in underlying assets which are not wholly financial in themselves, although they often move up and down in value in direct response to the trading in more purely financial [[Derivative (finance)|derivatives]]. Typically commodity markets depend on politics that affect international trade, e.g. boycotts and embargoes, or factors that influence [[natural capital]], e.g. weather that affects food crops. Meanwhile, stock markets are more influenced by trust in corporate leaders, i.e. [[individual capital]], by consumers, i.e. [[social capital]] or &quot;brand capital&quot; (in some analyses), and internal organizational efficiency, i.e. [[instructional capital]] and [[infrastructural capital]]. Some enterprises issue instruments to specifically track one limited division or brand.  &quot;[[Financial future]]s&quot;, &quot;[[Short selling]]&quot; and &quot;[[option (finance)|financial option]]s&quot; apply to these markets, and are typically pure financial bets on outcomes, rather than being a direct representation of any underlying asset.

==Broadening the notion==

The relationship between financial capital, [[money]], and all other styles of [[capital (economics)|capital]], especially [[human capital]] or [[labour (economics)|labor]], is assumed in [[central bank]] policy and regulations regarding instruments as above. Such relationships and policies are characterized by a [[political economy]] - [[feudalist]], [[socialist]], [[capitalism|capitalist]], [[Green politics|green]], [[anarchist]] or otherwise. In effect, the means of [[money supply]] and other regulations on financial capital represent the economic sense of the value system of the society itself, as they determine the allocation of labor in that society.

So, for instance, rules for increasing or reducing the money supply based on perceived [[inflation (economics)|inflation]], or on [[measuring well-being]], reflect some such [[theory of value (economics)|values]], reflect the importance of using (all forms of) financial capital as a stable store of value. If this is very important, inflation control is key - any amount of money inflation reduces the value of financial capital with respect to all other types.

If, however, the medium of exchange function is more critical, new money may be more freely issued regardless of impact on either inflation or well-being.

==Economic role==
[[Socialism]], [[capitalism]], [[feudalism]], [[anarchism]],  other [[civics|civic theories]] take markedly different views of the role of financial capital in social life, and propose various political restrictions to deal with that.

Financial capitalism is the production of profit from the manipulation of financial capital. It is held in contrast to [[industrial capitalism]], where profit is made from the manufacture of goods.

===Marxist perspectives===
{{main|Finance capitalism}}
It is common in [[Marxism|Marxist]] theory to refer to the role of Finance Capital as the determining and ruling class interest in capitalist society, particularly in the [[Late-stage capitalism|latter stages]].&lt;ref&gt;[[Imperialism, the Highest Stage of Capitalism]] [http://www.marxists.org/archive/lenin/works/1916/imp-hsc/ch03.htm ibid. Finance Capital and the Finance Oligarchy] {{webarchive|url=https://web.archive.org/web/20150402214909/https://www.marxists.org/archive/lenin/works/1916/imp-hsc/ch03.htm|date=2015-04-02}}&lt;/ref&gt;&lt;ref&gt;{{cite web|date=1 October 2009|title=Monopoly-Finance Capital and the Paradox of Accumulation - John Bellamy Foster - Monthly Review|url=http://www.monthlyreview.org/091001foster-mcchesney.php|url-status=live|archiveurl=https://web.archive.org/web/20110317032958/http://www.monthlyreview.org/091001foster-mcchesney.php|archivedate=17 March 2011|accessdate=3 May 2018|website=monthlyreview.org}}&lt;/ref&gt;

==See also==
*[[Capital market]]
*[[Constant item purchasing power accounting]]
*[[Financialization]]
*[[Funding]]
*[[Money supply]]
*[[List of finance topics]]

==References==
{{Reflist|30em}}
[http://bankofinfo.com/difference-between-shares-and-debentures/ Difference between Shares and Debentures]

==Further reading==
*F. Boldizzoni, ''Means and Ends: The Idea of Capital in the West, 1500-1970'', New York: Palgrave Macmillan, 2008, chapters 7-8

{{Types of capital}}

{{Authority control}}

[[Category:Financial capital| ]]

[[sv:Finansiellt kapital]]</text>
      <sha1>75yndd7yme5n2w9bxkevjfg2ebq3srs</sha1>
    </revision>
  </page>
  <page>
    <title>Natural resources</title>
    <ns>0</ns>
    <id>45808</id>
    <redirect title="Natural resource" />
    <revision>
      <id>965111593</id>
      <parentid>965111510</parentid>
      <timestamp>2020-06-29T13:31:58Z</timestamp>
      <contributor>
        <username>Viewmont Viking</username>
        <id>16944783</id>
      </contributor>
      <comment>Reverting back to stable</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="48" xml:space="preserve">#redirect [[Natural resource]] {{R from plural}}</text>
      <sha1>dpxq25htg62fimd5zotxx97f2rn9g5k</sha1>
    </revision>
  </page>
  <page>
    <title>Dijkstra's algorithm</title>
    <ns>0</ns>
    <id>45809</id>
    <revision>
      <id>990770203</id>
      <parentid>990222026</parentid>
      <timestamp>2020-11-26T11:51:35Z</timestamp>
      <contributor>
        <ip>2405:204:5023:39AF:60B1:A2FF:FE5B:8931</ip>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="46648" xml:space="preserve">{{short description|Graph search algorithm}}
{{Distinguish|Dykstra's projection algorithm}}
{{Use dmy dates|date=December 2019}}
{{Infobox algorithm
|class=[[Search algorithm]]&lt;br /&gt;[[Greedy algorithm]]&lt;br /&gt;[[Dynamic programming]]&lt;ref&gt;Controversial, see {{cite journal |author1=Moshe Sniedovich |title=Dijkstra's algorithm revisited: the dynamic programming connexion |journal=Control and Cybernetics |date=2006 |volume=35 |pages=599–620 |url=https://www.infona.pl/resource/bwmeta1.element.baztech-article-BAT5-0013-0005/tab/summary}} and [[#Dynamic programming perspective|below part]].&lt;/ref&gt;
|image=Dijkstra Animation.gif
|caption = Dijkstra's algorithm to find the shortest path between ''a'' and ''b''.  It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors.
|data=[[Graph (data structure)|Graph]]&lt;br&gt;Usually used with [[Priority queue]]/[[Heap (data structure)|Heap]] for optimization&lt;ref name=&quot;Intro&quot; /&gt;&lt;ref name=&quot;FibonacciH&quot; /&gt;
|time= &lt;math&gt;\Theta(|E| + |V| \log|V|)&lt;/math&gt;&lt;ref name=&quot;FibonacciH&quot;&gt;{{harvnb|Fredman|Tarjan|1987}}&lt;/ref&gt;
|best-time=
|average-time=
|space=
|optimal=
|complete=
}}
{{graph search algorithm}}

'''Dijkstra's algorithm''' (or '''Dijkstra's Shortest Path First algorithm''', '''SPF algorithm''')&lt;ref&gt;{{Cite web|url=https://www.cisco.com/c/en/us/td/docs/ios/12_0s/feature/guide/ospfispf.html|title=OSPF Incremental SPF|website=Cisco}}&lt;/ref&gt; is an [[algorithm]] for finding the [[shortest path problem|shortest paths]] between [[vertex (graph theory)|node]]s in a [[Graph (abstract data type)|graph]], which may represent, for example, [[road network]]s.  It was conceived by [[computer scientist]] [[Edsger W. Dijkstra]] in 1956 and published three years later.&lt;ref&gt;{{cite web |url=http://amturing.acm.org/award_winners/dijkstra_1053701.cfm |title=Edsger Wybe Dijkstra |last=Richards |first=Hamilton |website=A.M. Turing Award |publisher=Association for Computing Machinery |access-date=16 October 2017 |quote=At the Mathematical Centre a major project was building the ARMAC computer. For its official inauguration in 1956, Dijkstra devised a program to solve a problem interesting to a nontechnical audience: Given a network of roads connecting cities, what is the shortest route between two designated cities?}}&lt;/ref&gt;&lt;ref name=&quot;Dijkstra Interview&quot;&gt;{{cite journal|first=Phil |last=Frana |title=An Interview with Edsger W. Dijkstra|journal=Communications of the ACM|date=August 2010|volume=53|issue=8|pages=41–47 |doi=10.1145/1787234.1787249|doi-access=free}}&lt;/ref&gt;&lt;ref name=&quot;Dijkstra1959&quot;&gt;{{cite journal | authorlink = Edsger W. Dijkstra | first1 = E. W. | last1 = Dijkstra | s2cid = 123284777 | url= http://www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf | title = A note on two problems in connexion with graphs | journal = Numerische Mathematik | volume = 1 | year = 1959 | pages = 269–271 | ref = harv | doi = 10.1007/BF01386390}}&lt;/ref&gt;

The algorithm exists in many variants. Dijkstra's original algorithm found the shortest path between two given nodes,{{r|Dijkstra1959}} but a more common variant fixes a single node as the &quot;source&quot; node and finds shortest paths from the source to all other nodes in the graph, producing a [[shortest-path tree]].

For a given source node in the graph, the algorithm finds the shortest path between that node and every other.&lt;ref name=&quot;mehlhorn&quot;/&gt;{{rp|196–206}} It can also be used for finding the shortest paths from a single node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined. For example, if the nodes of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road (for simplicity, ignore red lights, stop signs, toll roads and other obstructions), Dijkstra's algorithm can be used to find the shortest route between one city and all other cities. A widely used application of shortest path algorithm is network [[routing protocol]]s, most notably [[IS-IS]] (Intermediate System to Intermediate System) and Open Shortest Path First ([[OSPF]]). It is also employed as a [[subroutine]] in other algorithms such as [[Johnson's algorithm|Johnson's]].

The Dijkstra algorithm uses labels that are positive integers or real numbers, which are [[total order|totally ordered]].  It can be generalized to use any labels that are [[partially ordered set|partially ordered]], provided the subsequent labels (a subsequent label is produced when traversing an edge) are [[monotonic function|monotonically]] non-decreasing.  This generalization is called the generic Dijkstra shortest-path algorithm.&lt;ref name = &quot;Generic Dijkstra&quot;&gt;{{cite journal | title = Generic Dijkstra for optical networks | journal = Journal of Optical Communications and Networking | volume = 11 | issue = 11 | pages = 568–577 | year = 2019 | last1 = Szcześniak | first1 = Ireneusz | last2 = Jajszczyk | first2 = Andrzej | last3 = Woźna-Szcześniak | first3 = Bożena| s2cid = 52958911 |doi = 10.1364/JOCN.11.000568|arxiv = 1810.04481}}&lt;/ref&gt;

Dijkstra's algorithm uses a data structure for storing and querying partial solutions sorted by distance from the start. While the original algorithm uses a [[min-priority queue]] and runs in [[time complexity|time]] &lt;math&gt;\Theta((|V| + |E|) \log |V|)&lt;/math&gt;(where &lt;math&gt;|V|&lt;/math&gt; is the number of nodes and &lt;math&gt;|E|&lt;/math&gt; is the number of edges), it can also be implemented in &lt;math&gt;\Theta(|V| ^ 2)&lt;/math&gt; using an array. The idea of this algorithm is also given in {{harvnb|Leyzorek|Gray|Johnson|Ladew|1957}}. {{harvnb|Fredman|Tarjan|1984}} propose using a [[Fibonacci heap]] min-priority queue to optimize the running time complexity to &lt;math&gt;\Theta(|E|+|V|\log|V|)&lt;/math&gt;. This is [[Asymptotic computational complexity|asymptotically]] the fastest known single-source [[shortest path problem|shortest-path algorithm]] for arbitrary [[directed graph]]s with unbounded non-negative weights. However, specialized cases (such as bounded/integer weights, directed acyclic graphs etc.) can indeed be improved further as detailed in [[Dijkstra's algorithm#Specialized  variants]].

In some fields, [[artificial intelligence]] in particular, Dijkstra's algorithm or a variant of it is known as '''uniform cost search''' and formulated as an instance of the more general idea of [[best-first search]].{{r|felner}}

== History ==
{{quote|What is the shortest way to travel from [[Rotterdam]] to [[Groningen]], in general: from given city to given city. [[Shortest path problem|It is the algorithm for the shortest path]], which I designed in about twenty minutes. One morning I was shopping in [[Amsterdam]] with my young fiancée, and tired, we sat down on the café terrace to drink a cup of coffee and I was just thinking about whether I could do this, and I then designed the algorithm for the shortest path. As I said, it was a twenty-minute invention. In fact, it was published in '59, three years later. The publication is still readable, it is, in fact, quite nice. One of the reasons that it is so nice was that I designed it without pencil and paper. I learned later that one of the advantages of designing without pencil and paper is that you are almost forced to avoid all avoidable complexities. Eventually, that algorithm became to my great amazement, one of the cornerstones of my fame.|Edsger Dijkstra, in an interview with Philip L. Frana, Communications of the ACM, 2001&lt;ref name=&quot;Dijkstra Interview&quot;/&gt;}}
Dijkstra thought about the shortest path problem when working at the [[Centrum Wiskunde &amp; Informatica|Mathematical Center in Amsterdam]] in 1956 as a programmer to demonstrate the capabilities of a new computer called ARMAC.&lt;ref&gt;{{cite web|title=ARMAC|url=http://www-set.win.tue.nl/UnsungHeroes/machines/armac.html|website=Unsung Heroes in Dutch Computing History|date=2007|archiveurl=https://web.archive.org/web/20131113021126/http://www-set.win.tue.nl/UnsungHeroes/machines/armac.html|archivedate=13 November 2013|url-status=dead}}&lt;/ref&gt; His objective was to choose both a problem and a solution (that would be produced by computer) that non-computing people could understand. He designed the shortest path algorithm and later implemented it for ARMAC for a slightly simplified transportation map of 64 cities in the Netherlands (64, so that 6 bits would be sufficient to encode the city number).&lt;ref name=&quot;Dijkstra Interview&quot;/&gt; A year later, he came across another problem from hardware engineers working on the institute's next computer: minimize the amount of wire needed to connect the pins on the back panel of the machine. As a solution, he re-discovered the algorithm known as [[Prim's algorithm|Prim's minimal spanning tree algorithm]] (known earlier to [[Vojtěch Jarník|Jarník]], and also rediscovered by [[Robert C. Prim|Prim]]).&lt;ref name=&quot;EWD841a&quot;&gt;{{citation | last1 = Dijkstra | first1 =Edsger W. | title = Reflections on &quot;A note on two problems in connexion with graphs | url = https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD841a.PDF}}&lt;/ref&gt;&lt;ref&gt;{{citation|first=Robert Endre|last=Tarjan|authorlink=Robert Endre Tarjan|title=Data Structures and Network Algorithms|series=CBMS_NSF Regional Conference Series in Applied Mathematics|volume=44|year=1983|publisher=Society for Industrial and Applied Mathematics|page=75|quote=The third classical minimum spanning tree algorithm was discovered by Jarník and rediscovered by Prim and Dikstra; it is commonly known as Prim's algorithm.}}&lt;/ref&gt; Dijkstra published the algorithm in 1959, two years after Prim and 29 years after Jarník.&lt;ref&gt;{{cite journal|last1=Prim|first1=R.C.|title=Shortest connection networks and some generalizations|journal=Bell System Technical Journal|date=1957|volume=36|issue=6|pages=1389–1401|doi=10.1002/j.1538-7305.1957.tb01515.x|url=http://bioinfo.ict.ac.cn/~dbu/AlgorithmCourses/Lectures/Prim1957.pdf|archiveurl=https://web.archive.org/web/20170718230207/http://bioinfo.ict.ac.cn/~dbu/AlgorithmCourses/Lectures/Prim1957.pdf|archivedate=18 July 2017|url-status=dead|access-date=18 July 2017|bibcode=1957BSTJ...36.1389P}}&lt;/ref&gt;&lt;ref&gt;V. Jarník: ''O jistém problému minimálním'' [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 6, 1930, pp.&amp;nbsp;57–63. (in Czech)&lt;/ref&gt;

== Algorithm ==
[[File:Dijkstras progress animation.gif|thumb|Illustration of Dijkstra's algorithm finding a path from a start node (lower left, red) to a goal node (upper right, green) in a [[robotics|robot]] [[motion planning]] problem. Open nodes represent the &quot;tentative&quot; set (aka set of &quot;unvisited&quot; nodes). Filled nodes are visited ones, with color representing the distance: the greener, the closer. Nodes in all the different directions are explored uniformly, appearing more-or-less as a circular [[wavefront]] as Dijkstra's algorithm uses a [[consistent heuristic|heuristic]] identically equal to 0.]]

Let the node at which we are starting be called the '''initial node'''. Let the '''distance of node ''Y''''' be the distance from the '''initial node''' to ''Y''. Dijkstra's algorithm will assign some initial distance values and will try to improve them step by step.

# Mark all nodes unvisited. Create a set of all the unvisited nodes called the ''unvisited set''.
# Assign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes. Set the initial node as current.&lt;ref&gt;{{Cite journal|last1=Gass|first1=Saul|last2=Fu|first2=Michael|editor2-first=Michael C|editor2-last=Fu|editor1-first=Saul I|editor1-last=Gass|date=2013|title=Dijkstra's Algorithm|journal=Encyclopedia of Operations Research and Management Science|publisher=Springer|volume=1|doi=10.1007/978-1-4419-1153-7|via=Springer Link|isbn=978-1-4419-1137-7}}&lt;/ref&gt;
# For the current node, consider all of its unvisited neighbours and calculate their ''tentative'' distances through the current node. Compare the newly calculated ''tentative'' distance to the current assigned value and assign the smaller one. For example, if the current node ''A'' is marked with a &lt;!--tentative ((commented out because the distance is NOT tentative.. it cannot change while visiting the neighbors.. so calling it tentative implies that it can still change, which is confusing))--&gt; distance of 6, and the edge connecting it with a neighbour ''B'' has length 2, then the distance to ''B'' through ''A'' will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, the current value will be kept.
# When we are done considering all of the unvisited neighbours of the current node, mark the current node as visited and remove it from the ''unvisited set''. A visited node will never be checked again.
&lt;!-- its distance recorded now is final and minimal. ((commented out because the distance is final for the current-node at the point it is taken from the queue.. the distance cannot be dropped while visiting the neighbours.. yet, the current-node remains unvisited until this step.  This is inconsistent and confusing.)) --&gt;
&lt;!-- # Move to the next unvisited node with the smallest tentative distance and repeat the above steps which check neighbours and mark visited. ((I think that if this line exist, then we cannot terminate the algorithm)) --&gt;
# If the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the ''unvisited set'' is infinity (when planning a complete traversal; occurs when there is no connection between the initial node and remaining unvisited nodes), then stop. The algorithm has finished.
# Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new &quot;current node&quot;, and go back to step 3.

When planning a route, it is actually not necessary to wait until the destination node is &quot;visited&quot; as above: the algorithm can stop once the destination node has the smallest tentative distance among all &quot;unvisited&quot; nodes (and thus could be selected as the next &quot;current&quot;).

== Description ==
{{Hatnote|'''Note:''' For ease of understanding, this discussion uses the terms '''intersection''', '''road''' and '''map''' – however, in formal terminology these terms are '''vertex''', '''edge''' and '''graph''', respectively.}}

Suppose you would like to find the ''shortest path'' between two [[Intersection (road)|intersections]] on a city map: a ''starting point'' and a ''destination''. Dijkstra's algorithm initially marks the distance (from the starting point) to every other intersection on the map with ''infinity''. This is done not to imply that there is an infinite distance, but to note that those intersections have not been visited yet. Some variants of this method leave the intersections' distances ''unlabeled''. Now select the ''current intersection'' at each iteration.  For the first iteration, the current intersection will be the starting point, and the distance to it (the intersection's label) will be ''zero''. For subsequent iterations (after the first), the current intersection will be a ''closest unvisited intersection'' to the starting point (this will be easy to find).

From the current intersection, ''update'' the distance to every unvisited intersection that is directly connected to it. This is done by determining the ''sum'' of the distance between an unvisited intersection and the value of the current intersection and then [[Graph labeling|relabeling]] the unvisited intersection with this value (the sum) if it is less than the unvisited intersection's current value. In effect, the intersection is relabeled if the path to it through the current intersection is shorter than the previously known paths.  To facilitate shortest path identification, in pencil, mark the road with an arrow pointing to the relabeled intersection if you label/relabel it, and erase all others pointing to it.  After you have updated the distances to each [[Neighbourhood (graph theory)|neighboring intersection]], mark the current intersection as ''visited'' and select an unvisited intersection with minimal distance (from the starting point) – or the lowest label—as the current intersection. Intersections marked as visited are labeled with the shortest path from the starting point to it and will not be revisited or returned to.

Continue this process of updating the neighboring intersections with the shortest distances, marking the current intersection as visited, and moving onto a closest unvisited intersection until you have marked the destination as visited. Once you have marked the destination as visited (as is the case with any visited intersection), you have determined the shortest path to it from the starting point and can ''trace your way back following the arrows in reverse''. In the algorithm's implementations, this is usually done (after the algorithm has reached the destination node) by following the nodes' parents from the destination node up to the starting node; that's why we also keep track of each node's parent.

This algorithm makes no attempt of direct &quot;exploration&quot; towards the destination as one might expect. Rather, the sole consideration in determining the next &quot;current&quot; intersection is its distance from the starting point. This algorithm therefore expands outward from the starting point, interactively considering every node that is closer in terms of shortest path distance until it reaches the destination. When understood in this way, it is clear how the algorithm necessarily finds the shortest path. However, it may also reveal one of the algorithm's weaknesses: its relative slowness in some topologies.

==Pseudocode==

In the following [[pseudocode]] algorithm, the code {{mono|u ← vertex in ''Q'' with min dist[u]}}, searches for the vertex {{mono|&lt;var&gt;u&lt;/var&gt;}} in the vertex set {{mono|&lt;var&gt;Q&lt;/var&gt;}} that has the least {{mono|dist[&lt;var&gt;u&lt;/var&gt;]}} value. {{mono|length(&lt;var&gt;u&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt;)}} returns the length of the edge joining (i.e. the distance between) the two neighbor-nodes {{mono|&lt;var&gt;u&lt;/var&gt;}} and {{mono|&lt;var&gt;v&lt;/var&gt;}}. The variable {{mono|&lt;var&gt;alt&lt;/var&gt;}} on line 18 is the length of the path from the root node to the neighbor node {{mono|&lt;var&gt;v&lt;/var&gt;}} if it were to go through {{mono|&lt;var&gt;u&lt;/var&gt;}}. If this path is shorter than the current shortest path recorded for {{mono|&lt;var&gt;v&lt;/var&gt;}}, that current path is replaced with this {{mono|&lt;var&gt;alt&lt;/var&gt;}} path. The {{mono|prev}} array is populated with a pointer to the &quot;next-hop&quot; node on the source graph to get the shortest route to the source.
[[File:DijkstraDemo.gif|thumb|A demo of Dijkstra's algorithm based on Euclidean distance. Red lines are the shortest path covering, i.e., connecting ''u'' and prev[''u'']. Blue lines indicate where relaxing happens, i.e., connecting ''v'' with a node ''u'' in ''Q'', which gives a shorter path from the source to ''v''.]]

  1  '''function''' Dijkstra(''Graph'', ''source''):
  2
  3      create vertex set Q
  4
  5      '''for each''' vertex ''v'' in ''Graph'':            
  6          dist[''v''] ← INFINITY                 
  7          prev[''v''] ← UNDEFINED                
  8          add ''v'' to ''Q''                     
  9      dist[''source''] ← 0                       
 10     
 11      '''while''' ''Q'' is not empty:
 12          ''u'' ← vertex in ''Q'' with min dist[u]   
 13                                             
 14          remove ''u'' from ''Q''
 15         
 16          '''for each''' neighbor ''v'' of ''u'':           ''// only v that are still in Q''
 17              ''alt'' ← dist[''u''] + length(''u'', ''v'')
 18              '''if''' ''alt'' &lt; dist[''v'']:              
 19                  dist[''v''] ← ''alt''
 20                  prev[''v''] ← ''u''
 21
 22      '''return''' dist[], prev[]

If we are only interested in a shortest path between vertices {{mono|&lt;var&gt;source&lt;/var&gt;}} and {{mono|&lt;var&gt;target&lt;/var&gt;}}, we can terminate the search after line 15 if {{mono|&lt;var&gt;u&lt;/var&gt; {{=}} &lt;var&gt;target&lt;/var&gt;}}.
Now we can read the shortest path from {{mono|&lt;var&gt;source&lt;/var&gt;}} to {{mono|&lt;var&gt;target&lt;/var&gt;}} by reverse iteration:

 1  ''S'' ← empty sequence
 2  ''u'' ← ''target''
 3  '''if''' prev[''u''] is defined '''or''' ''u'' = ''source'':          ''// Do something only if the vertex is reachable''
 4      '''while''' ''u'' is defined:                       ''// Construct the shortest path with a stack S''
 5          insert ''u'' at the beginning of ''S''        ''// Push the vertex onto the stack''
 6          ''u'' ← prev[''u'']                           ''// Traverse from target to source''

Now sequence {{mono|&lt;var&gt;S&lt;/var&gt;}} is the list of vertices constituting one of the shortest paths from {{mono|&lt;var&gt;source&lt;/var&gt;}} to {{mono|&lt;var&gt;target&lt;/var&gt;}}, or the empty sequence if no path exists.

A more general problem would be to find all the shortest paths between {{mono|&lt;var&gt;source&lt;/var&gt;}} and {{mono|&lt;var&gt;target&lt;/var&gt;}} (there might be several different ones of the same length). Then instead of storing only a single node in each entry of {{mono|prev[]}} we would store all nodes satisfying the relaxation condition. For example, if both {{mono|&lt;var&gt;r&lt;/var&gt;}} and {{mono|&lt;var&gt;source&lt;/var&gt;}} connect to {{mono|&lt;var&gt;target&lt;/var&gt;}} and both of them lie on different shortest paths through {{mono|&lt;var&gt;target&lt;/var&gt;}} (because the edge cost is the same in both cases), then we would add both {{mono|&lt;var&gt;r&lt;/var&gt;}} and {{mono|&lt;var&gt;source&lt;/var&gt;}} to {{mono|prev[&lt;var&gt;target&lt;/var&gt;]}}. When the algorithm completes, {{mono|prev[]}} data structure will actually describe a graph that is a subset of the original graph with some edges removed. Its key property will be that if the algorithm was run with some starting node, then every path from that node to any other node in the new graph will be the shortest path between those nodes in the original graph, and all paths of that length from the original graph will be present in the new graph. Then to actually find all these shortest paths between two given nodes we would use a path finding algorithm on the new graph, such as [[depth-first search]].

===Using a priority queue===
