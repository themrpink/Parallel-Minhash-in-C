== External links ==
{{Commons category}}
{{Wikiquote}}
{{Wikisource author}}
{{Library resources box |by=yes |onlinebooks=yes |others=yes |about=yes |label=Eratosthenes
  |viaf= |lccn= |lcheading= |wikititle= }}
* [http://www.roger-pearse.com/weblog/2017/04/15/cleomedes-how-big-is-the-earth/ English translation of the primary source for Eratosthenes and the size of the Earth] at Roger Pearse.
* [http://www.wilbourhall.org/index.html#eratosthenes Bernhardy, Gottfried: ''Eratosthenica'' ] Berlin, 1822 (PDF) (Latin/Greek), Reprinted Osnabruck 1968 (German)
* [http://www.faust.fr.bw.schule.de/mhb/eratosiv.htm Eratosthenes' sieve in Javascript]
* [http://www.math.utah.edu/~pa/Eratosthenes.html About Eratosthenes' methods, including a Java applet]
* [http://galileoandeinstein.physics.virginia.edu/lectures/gkastr1.html How the Greeks estimated the distances to the Moon and Sun]
* [http://astrosun2.astro.cornell.edu/academics/courses//astro201/eratosthenes.htm Measuring the Earth with Eratosthenes' method]
* [http://aleph0.clarku.edu/~djoyce/mathhist/greece.html List of ancient Greek mathematicians and contemporaries of Eratosthenes]
* [http://www.newadvent.org/cathen/01303a.htm New Advent Encyclopedia article on the Library of Alexandria]
* [http://www.quitebasic.com/prj/math/eratosthenes/ Eratosthenes' sieve in classic BASIC all-web based interactive programming environment]
* [https://www.fondation-lamap.org/en/node/9786' International pedagogical project] : project [[:fr:La main à la pâte]].
* [http://www.phy.ntnu.edu.tw/ntnujava/htmltag.php?code=users.sgeducation.lookang.Eratostheneswee_pkg.EratosthenesweeApplet.class&amp;name=Eratostheneswee&amp;muid=14019 Open source Physics Computer Model about Eratosthenes estimation of radius and circumference of Earth]
* [https://web.archive.org/web/20151030065030/http://www.mozalearn.com/Extra-Videos-Eratosthenes-209501 Eratosthenes, video]
* [https://www.astrologicon.org/eratosthenes/eratosthenes-katasterismoi1.html Eratosthenes, Katasterismoi (or Astrothesiae), original text]

{{S-start}}
{{S-bef|before=[[Apollonius of Rhodes]]}}
{{S-ttl|title=Head of the [[Library of Alexandria]]}}
{{S-aft|after=[[Aristophanes of Byzantium]]}}
{{S-end}}

{{Ancient Greek astronomy}}
{{Ancient Greek mathematics}}

{{Authority control}}

[[Category:3rd-century BC Greek people]]
[[Category:3rd-century BC poets]]
[[Category:Ancient Greek astronomers]]
[[Category:Ancient Greek geographers]]
[[Category:Ancient Greek music theorists]]
[[Category:Ancient Greek mathematicians]]
[[Category:Ancient Greek poets]]
[[Category:Ancient Greek inventors]]
[[Category:Cyrenean Greeks]]
[[Category:Deaths by starvation]]
[[Category:Geodesists]]
[[Category:Geometers]]
[[Category:3rd-century BC Egyptian people]]
[[Category:Librarians of Alexandria]]
[[Category:Number theorists]]
[[Category:270s BC births]]
[[Category:190s BC deaths]]
[[Category:276 BC births]]
[[Category:Giftedness]]</text>
      <sha1>cuufgosyn90lr9ljyjinmw4yixp58w9</sha1>
    </revision>
  </page>
  <page>
    <title>Iona Nikitchenko</title>
    <ns>0</ns>
    <id>46118</id>
    <revision>
      <id>989489720</id>
      <parentid>969994139</parentid>
      <timestamp>2020-11-19T08:07:49Z</timestamp>
      <contributor>
        <username>2x2leax</username>
        <id>16771471</id>
      </contributor>
      <minor />
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="5409" xml:space="preserve">[[File:Russian judges at Nuremberg.jpg|right|thumbnail|250px|Soviet judges at Nuremberg, left to right: [[Alexander Volchkov (jurist)|Alexander Volchkov]], Iona Nikitchenko.  British judge, [[William Norman Birkett, 1st Baron Birkett|Norman Birkett]] sat at extreme right.]]
Major-General '''Iona Timofeevich Nikitchenko''' (Russian: Иона  Тимофеевич Никитченко) (June 28, 1895 – April 22, 1967) was a [[judge]] of the [[Supreme Court of the Soviet Union]].

Iona was born to a peasant family in [[khutor]] Tuzlukov (now [[Rostov Oblast]]). He studied at his local Agricultural Institute and from 1916 was a  [[Communist Party of the Soviet Union|Bolshevik]]. His court experience started in May 1920 when he was appointed as the chairman-deputy of the Military Court of Semirechye Army Group during the Civil War. During the Civil War, he participated on the frontlines in the Middle Asia. In 1924, he was appointed as the member of the Military Court Collegiate of the Moscow Military District.

Nikitchenko presided over some of the most notorious of [[Joseph Stalin]]'s [[show trial]]s during the [[Great Purge]]s of 1936 to 1938, where he among other things sentenced [[Lev Kamenev|Kamenev]] and [[Grigory Zinoviev|Zinoviev]].&lt;ref&gt;[http://slovari.yandex.ru/dict/krugosvet/article/9/96/1009560.htm Encyclopedia Krugosvet]{{Dead link|date=January 2020 |bot=InternetArchiveBot |fix-attempted=yes }} {{in lang|ru}}&lt;/ref&gt;&lt;ref&gt;[http://www.belousenko.com/books/gulag/reabil_posmert_2.htm Реабилитирован посмертно] Belosenko.ru {{in lang|ru}}&lt;/ref&gt;
==Nuremberg trials==
Nikitchenko was one of the three main drafters of the [[London Charter of the International Military Tribunal|London Charter]]. He was also the Soviet Union's judge at the [[Nuremberg trials]], and was President for the session at [[Berlin]]. Nikitchenko's prejudices were evident from the outset. Before the Tribunal convened, Nikitchenko explained the Soviet perspective of the trials:&lt;blockquote&gt;&quot;We are dealing here with the chief war criminals who have already been convicted and whose conviction has been already announced by both the Moscow and Crimea [Yalta] declarations by the heads of the [Allied] governments.... The whole idea is to secure quick and just punishment for the crime.&quot;&lt;ref&gt;[http://www.yale.edu/lawweb/avalon/imt/jackson/jack17.htm on June 29, 1945] {{webarchive|url=https://web.archive.org/web/20041210174640/http://www.yale.edu/lawweb/avalon/imt/jackson/jack17.htm |date=December 10, 2004 }} (8. Report of Robert Jackson, United States Representative to the [[London Charter of the International Military Tribunal|International Conference on Military Trials, London]], 1945 (Washington, DC: US State Dept., 1949), pp. 104-106, 303.; [[Whitney R. Harris]], Tyranny on Trial: The Evidence at Nuremberg (Dallas: S.M.U. Press, 1954), pp. 16-17.)&lt;/ref&gt;&lt;/blockquote&gt;

His statements in this respect call to mind the statements of US Supreme Court Chief Justice [[Harlan Fiske Stone]] who wrote &quot;Chief US prosecutor Jackson is away conducting his high-grade lynching party in Nuremberg, I don't mind what he does to the Nazis, but I hate to see the pretense that he is running a court and proceeding according to common law. This is a little too sanctimonious a fraud to meet my old-fashioned ideas.&quot;&lt;ref&gt;Alpheus T. Mason, ''Harlan Fiske Stone: Pillar of the Law'', New York, Viking, 1956, p. 716. Quoted by Louise Arbour, &quot;The Rule of Law and the Reach of Accountability&quot;, in [[Cheryl Saunders]] and Katherine Le Roy (ed.), ''The Rule of Law'', Federation Press, 2003, p. 104 and p. 125, note 2.&lt;/ref&gt; 

Nikitchenko dissented against the acquittals of [[Hjalmar Schacht]], [[Franz von Papen]] and [[Hans Fritzsche]], and argued for a death sentence for [[Rudolf Hess]]. Nikitchenko said, in the lead-up to the trials, &quot;If... the judge is supposed to be impartial, it would only lead to unnecessary delays.&quot; Hess, formerly Hitler's deputy fuhrer, the man charged by Hitler with implementing [[Nazi Germany]]'s [[Nuremberg Laws]], the man who signed the decree establishing the notorious German occupation government of Poland, and since May 1941 in a British prison, was sentenced to life in prison by the tribunal. In this respect, he was by far the most senior surviving Nazi official to escape a death sentence. Nikitchenko also found the majority judgments incorrect with regard to the [[Hitler Cabinet|Reich Cabinet]], the [[German General Staff]] and the [[Oberkommando der Wehrmacht]]. Having never before written a dissenting opinion—these being unheard of in Soviet jurisprudence—and being unsure of the form of such an opinion, Nikitchenko was assisted in writing his dissents by his fellow judge [[Norman Birkett]].

Nikitchenko feared a compromise on too lenient a level. At the point of final deliberation he reexamined Hess' case and voted for a life sentence so that the opportunity for Hess to get away with a lesser degree of punishment did not occur.

==References==
{{reflist}}

{{Nuremberg Trial judges|Nikitchenko, Iona}}

{{DEFAULTSORT:Nikitchenko, Iona}}
[[Category:1895 births]]
[[Category:1967 deaths]]
[[Category:Soviet people of World War II]]
[[Category:Soviet jurists]]
[[Category:20th-century jurists]]
[[Category:Judges of the International Military Tribunal in Nuremberg]]
[[Category:Soviet judges of international courts and tribunals]]</text>
      <sha1>lqyzkh510es9piyy91cqsidn7j7iapx</sha1>
    </revision>
  </page>
  <page>
    <title>Nikitchenko</title>
    <ns>0</ns>
    <id>46119</id>
    <redirect title="Iona Nikitchenko" />
    <revision>
      <id>694490804</id>
      <parentid>687918989</parentid>
      <timestamp>2015-12-09T16:27:35Z</timestamp>
      <contributor>
        <username>Nymf</username>
        <id>5515357</id>
      </contributor>
      <minor />
      <comment>Reverted edits by [[Special:Contribs/A window cleaner me|A window cleaner me]] ([[User talk:A window cleaner me|talk]]) to last version by Timwi</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="30" xml:space="preserve">#REDIRECT [[Iona Nikitchenko]]</text>
      <sha1>dgm81oc4xfz26bb3d2j2u9qk1ogs17e</sha1>
    </revision>
  </page>
  <page>
    <title>Range encoding</title>
    <ns>0</ns>
    <id>46120</id>
    <revision>
      <id>990958867</id>
      <parentid>876429980</parentid>
      <timestamp>2020-11-27T14:11:37Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>change source to syntaxhighlight</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="14043" xml:space="preserve">'''Range encoding''' is an [[entropy coding]] method defined by G.&amp;nbsp;Nigel&amp;nbsp;N.&amp;nbsp;Martin in a 1979 paper,&lt;ref name=compressconsult&gt;[http://www.compressconsult.com/rangecoder/#download G.&amp;nbsp;Nigel&amp;nbsp;N.&amp;nbsp;Martin, ''Range encoding: An algorithm for removing redundancy from a digitized message''], Video &amp; Data Recording Conference, [[Southampton]], UK, July 24–27, 1979.&lt;/ref&gt; which effectively rediscovered the FIFO arithmetic code first introduced by Richard Clark Pasco in 1976.&lt;ref&gt;&quot;Source coding algorithms for fast data compression&quot; Richard Clark Pasco, Stanford, CA 1976&lt;/ref&gt; Given a stream of symbols and their probabilities, a range coder produces a space-efficient stream of bits to represent these symbols and, given the stream and the probabilities, a range decoder reverses the process.

Range coding is very similar to [[arithmetic encoding]], except that encoding is done with digits in any base, instead of with bits, and so it is faster when using larger bases (e.g. a [[byte]]) at small cost in compression efficiency.&lt;ref&gt;&quot;[http://people.xiph.org/~tterribe/notes/range.html On the Overhead of Range Coders]&quot;, Timothy B. Terriberry, Technical Note 2008&lt;/ref&gt; After the expiration of the first (1978) arithmetic coding patent,&lt;ref&gt;{{US patent|4122440}} &amp;mdash; (IBM) Filed March 4, 1977, Granted 24 October 1978 (Now expired)&lt;/ref&gt; range encoding appeared to clearly be free of patent encumbrances. This particularly drove interest in the technique in the [[open source]] community. Since that time, patents on various well-known arithmetic coding techniques have also expired.

== How range encoding works ==
[[File:Range encoding.jpg|thumb|right|Graphical representation of the encoding process. The message being encoded here is &quot;AABA&lt;EOM&gt;&quot;]]
Range encoding conceptually encodes all the symbols of the message into one number, unlike [[Huffman coding]] which assigns each symbol a bit-pattern and concatenates all the bit-patterns together. Thus range encoding can achieve greater compression ratios than the one-bit-per-symbol lower bound on [[Huffman encoding]] and it does not suffer the inefficiencies that Huffman does when dealing with probabilities that are not exact [[power of two|powers of two]].

The central concept behind range encoding is this: given a large-enough range of [[integer]]s, and a probability estimation for the symbols, the initial range can easily be divided into sub-ranges whose sizes are proportional to the probability of the symbol they represent. Each symbol of the message can then be encoded in turn, by reducing the current range down to just that sub-range which corresponds to the next symbol to be encoded. The decoder must have the same probability estimation the encoder used, which can either be sent in advance, derived from already transferred data or be part of the compressor and decompressor.

When all symbols have been encoded, merely identifying the sub-range is enough to communicate the entire message (presuming of course that the decoder is somehow notified when it has extracted the entire message). A single integer is actually sufficient to identify the sub-range, and it may not even be necessary to transmit the entire integer; if there is a sequence of digits such that every integer beginning with that prefix falls within the sub-range, then the prefix alone is all that's needed to identify the sub-range and thus transmit the message.

=== Example ===
Suppose we want to encode the message &quot;AABA&lt;EOM&gt;&quot;, where &lt;EOM&gt; is the end-of-message symbol. For this example it is assumed that the decoder knows that we intend to encode exactly five symbols in the [[decimal|base 10 number system]] (allowing for 10&lt;sup&gt;5&lt;/sup&gt; different combinations of symbols with the range &lt;nowiki&gt;[0, 100000)&lt;/nowiki&gt;) using the [[probability distribution]] {A: .60; B: .20; &lt;EOM&gt;: .20}. The encoder breaks down the range &lt;nowiki&gt;[0, 100000)&lt;/nowiki&gt; into three subranges:

 &lt;nowiki&gt;A:     [     0,  60000)&lt;/nowiki&gt;
 &lt;nowiki&gt;B:     [ 60000,  80000)&lt;/nowiki&gt;
 &lt;nowiki&gt;&lt;EOM&gt;: [ 80000, 100000)&lt;/nowiki&gt;

Since our first symbol is an A, it reduces our initial range down to &lt;nowiki&gt;[0, 60000)&lt;/nowiki&gt;. The second symbol choice leaves us with three sub-ranges of this range. We show them following the already-encoded 'A':

 &lt;nowiki&gt;AA:     [     0,  36000)&lt;/nowiki&gt;
 &lt;nowiki&gt;AB:     [ 36000,  48000)&lt;/nowiki&gt;
 &lt;nowiki&gt;A&lt;EOM&gt;: [ 48000,  60000)&lt;/nowiki&gt;

With two symbols encoded, our range is now &lt;nowiki&gt;[0, 36000)&lt;/nowiki&gt; and our third symbol leads to the following choices:

 &lt;nowiki&gt;AAA:     [     0,  21600)&lt;/nowiki&gt;
 &lt;nowiki&gt;AAB:     [ 21600,  28800)&lt;/nowiki&gt;
 &lt;nowiki&gt;AA&lt;EOM&gt;: [ 28800,  36000)&lt;/nowiki&gt;

This time it is the second of our three choices that represent the message we want to encode, and our range becomes &lt;nowiki&gt;[21600, 28800)&lt;/nowiki&gt;. It may look harder to determine our sub-ranges in this case, but it is actually not: we can merely subtract the lower bound from the upper bound to determine that there are 7200 numbers in our range; that the first 4320 of them represent 0.60 of the total, the next 1440 represent the next 0.20, and the remaining 1440 represent the remaining 0.20 of the total. Adding back the lower bound gives us our ranges:

 &lt;nowiki&gt;AABA:     [21600, 25920)&lt;/nowiki&gt;
 &lt;nowiki&gt;AABB:     [25920, 27360)&lt;/nowiki&gt;
 &lt;nowiki&gt;AAB&lt;EOM&gt;: [27360, 28800)&lt;/nowiki&gt;

Finally, with our range narrowed down to &lt;nowiki&gt;[21600, 25920)&lt;/nowiki&gt;, we have just one more symbol to encode. Using the same technique as before for dividing up the range between the lower and upper bound, we find the three sub-ranges are:

 &lt;nowiki&gt;AABAA:     [21600, 24192)&lt;/nowiki&gt;
 &lt;nowiki&gt;AABAB:     [24192, 25056)&lt;/nowiki&gt;
 &lt;nowiki&gt;AABA&lt;EOM&gt;: [25056, 25920)&lt;/nowiki&gt;

And since &lt;EOM&gt; is our final symbol, our final range is &lt;nowiki&gt;[25056, 25920)&lt;/nowiki&gt;. Because all five-digit integers starting with &quot;251&quot; fall within our final range, it is one of the three-digit prefixes we could transmit that would unambiguously convey our original message. (The fact that there are actually eight such prefixes in all implies we still have inefficiencies. They have been introduced by our use of [[decimal|base 10]] rather than [[Binary numeral system|base 2]].)

The central problem may appear to be selecting an initial range large enough that no matter how many symbols we have to encode, we will always have a current range large enough to divide into non-zero sub-ranges. In practice, however, this is not a problem, because instead of starting with a very large range and gradually narrowing it down, the encoder works with a smaller range of numbers at any given time. After some number of digits have been encoded, the leftmost digits will not change. In the example after encoding just three symbols, we already knew that our final result would start with &quot;2&quot;. More digits are shifted in on the right as digits on the left are sent off. This is illustrated in the following code:

&lt;syntaxhighlight lang=&quot;csharp&quot;&gt;
int low = 0;
int range = 100000;

void Run()
{
	Encode(0, 6, 10);	// A
	Encode(0, 6, 10);	// A
	Encode(6, 2, 10);	// B
	Encode(0, 6, 10);	// A
	Encode(8, 2, 10);	// &lt;EOM&gt;

	// emit final digits - see below
	while (range &lt; 10000)
		EmitDigit();

	low += 10000;
	EmitDigit();
}

void EmitDigit()
{
	Console.Write(low / 10000);
	low = (low % 10000) * 10;
	range *= 10;
}

void Encode(int start, int size, int total)
{
	// adjust the range based on the symbol interval
	range /= total;
	low += start * range;
	range *= size;

	// check if left-most digit is same throughout range
	while (low / 10000 == (low + range) / 10000)
		EmitDigit();

	// readjust range - see reason for this below
	if (range &lt; 1000)
	{
		EmitDigit();
		EmitDigit();
		range = 100000 - low;
	}
}
&lt;/syntaxhighlight&gt;

To finish off we may need to emit a few extra digits. The top digit of &lt;code&gt;low&lt;/code&gt; is probably too small so we need to increment it, but we have to make sure we don't increment it past &lt;code&gt;low+range&lt;/code&gt;. So first we need to make sure &lt;code&gt;range&lt;/code&gt; is large enough.

&lt;syntaxhighlight lang=&quot;csharp&quot;&gt;
// emit final digits
while (range &lt; 10000)
	EmitDigit();

low += 10000;
EmitDigit();
&lt;/syntaxhighlight&gt;

One problem that can occur with the &lt;code&gt;Encode&lt;/code&gt; function above is that &lt;code&gt;range&lt;/code&gt; might become very small but &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;low+range&lt;/code&gt; still have differing first digits. This could result in the interval having insufficient precision to distinguish between all of the symbols in the alphabet. When this happens we need to fudge a little, output the first couple of digits even though we might be off by one, and re-adjust the range to give us as much room as possible. The decoder will be following the same steps so it will know when it needs to do this to keep in sync.

&lt;syntaxhighlight lang=&quot;csharp&quot;&gt;
// this goes just before the end of Encode() above
if (range &lt; 1000)
{
	EmitDigit();
	EmitDigit();
	range = 100000 - low;
}
&lt;/syntaxhighlight&gt;

Base 10 was used in this example, but a real implementation would just use binary, with the full range of the native integer data type. Instead of &lt;code&gt;10000&lt;/code&gt; and &lt;code&gt;1000&lt;/code&gt; you would likely use hexadecimal constants such as &lt;code&gt;0x1000000&lt;/code&gt; and &lt;code&gt;0x10000&lt;/code&gt;. Instead of emitting a digit at a time you would emit a byte at a time and use a byte-shift operation instead of multiplying by 10.

Decoding uses exactly the same algorithm with the addition of keeping track of the current &lt;code&gt;code&lt;/code&gt; value consisting of the digits read from the compressor. Instead of emitting the top digit of &lt;code&gt;low&lt;/code&gt; you just throw it away, but you also shift out the top digit of &lt;code&gt;code&lt;/code&gt; and shift in a new digit read from the compressor. Use &lt;code&gt;AppendDigit&lt;/code&gt; below instead of &lt;code&gt;EmitDigit&lt;/code&gt;.

&lt;syntaxhighlight lang=&quot;csharp&quot;&gt;
int code = 0;
int low = 0;
int range = 1;

void InitializeDecoder()
{
        AppendDigit();  // with this example code, only 1 of these is actually needed
        AppendDigit();
        AppendDigit();
        AppendDigit();
        AppendDigit();
}

void AppendDigit()
{
	code = (code % 10000) * 10 + ReadNextDigit();
	low = (low % 10000) * 10;
	range *= 10;
}

void Decode(int start, int size, int total)  // Decode is same as Encode with EmitDigit replaced by AppendDigit
{
	// adjust the range based on the symbol interval
	range /= total;
	low += start * range;
	range *= size;

	// check if left-most digit is same throughout range
	while (low / 10000 == (low + range) / 10000)
		AppendDigit();

	// readjust range - see reason for this below
	if (range &lt; 1000)
	{
		AppendDigit();
		AppendDigit();
		range = 100000 - low;
	}
}
&lt;/syntaxhighlight&gt;
